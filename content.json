[{"title":"Maven依赖冲突","date":"2020-10-23T07:58:12.000Z","path":"2020/10/23/Maven依赖冲突/","text":"maven依赖冲突由于依赖传递现象的存在，spring-webmvc-4.24依赖spring-beans-4.2.4, spring-aop-5.0.2依赖spring-beans-5.0.2,但是发现spring-beans-4.2.4加入到了工程中,而我们希望spring-beans-5.0.2加入工程。这就造成了依赖冲突。 如何解决maven依赖冲突使用maven提供的依赖调解原则 第一声明者优先原则：在pom文件中定义依赖，以先声明的依赖为准。其实就是根据坐标导入的顺序来确定最终使用哪个传递过来的依赖。 路径近者优先原则：在pom文件定义依赖，以路径近者为准。还是上述情况, spring-aop和spring-webmvc都会传递过来spring-beans,那如果直接把spring-beans的依赖直接写到pom文件中,那么项目就不会再使用其他依赖传递来的spring- beans,因为自己直接在pom中定义spring-beans要比其他依赖传递过来的路径要近。 排除依赖可以使用exclusions标签将传递过来的依赖排除出去 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;!-- 排除依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 锁定版本采用直接锁定版本的方法确定依赖jar包的版本,版本锁定后则不考虑依赖的声明顺序或依赖的路径,以锁定的版本为准添加到工程中，此方法在企业开发中经常使用。 版本锁定的使用方式:第一步:在dependencyManagement标签中锁定依赖的版本第二步:在dependencies标签中声明需要导入的maven坐标 1234567891011121314151617&lt;!--依赖jar包版本锁定，并不会真正导入--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;!--由于已经在dependencyManagement锁定了版本，此处无需在指定version--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;","tags":[]},{"title":"Mybatis整合SSM项目","date":"2020-10-14T12:59:25.000Z","path":"2020/10/14/Mybatis整合SSM项目/","text":"SSM框架整合原始整合方式环境搭建 搭建数据库，创建数据库表 创建Maven工程 导入Maven坐标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1-b03&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写实体类 编写Mapper接口（可采用注解开发） 编写service接口 编写service接口实现 123456789101112131415@Overridepublic List&lt;Account&gt; findAll() &#123; try &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sessionFactory.openSession(); AccountMapper mapper = sqlSession.getMapper(AccountMapper.class); List&lt;Account&gt; accountList = mapper.findAll(); sqlSession.close(); return accountList; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null;&#125; 编写controller 123456789//查询@RequestMapping(\"/findAll\")public ModelAndView findAll()&#123; List&lt;Account&gt; accountList = accountService.findAll(); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"accountList\", accountList); modelAndView.setViewName(\"accountList\"); return modelAndView;&#125; 编写前端页面 编写相应配置文件 Spring配置文件: applicationContext.xml SprngMVC配置文件: spring-mvc.xml MyBatis映射文件: AccountMapper.xml MyBatis核心文件: sqlMapConfig.xml 数据库连接信息文件: jdbc.properties Web.xmI文件: web.xml 日志文件: log4j.properties web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--spring监听器--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--springmvc前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--乱码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; applicationContext.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=\"top.rainbowcat\"&gt; &lt;!--排除controller--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; spring-mvc.xml 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--组件扫描，主要扫controller--&gt; &lt;context:component-scan base-package=\"top.rainbowcat.controller\" /&gt; &lt;!--配置mvc注解驱动--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--内部资源视图解析器--&gt; &lt;bean id=\"resourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!--开放静态资源访问权限--&gt; &lt;mvc:default-servlet-handler /&gt;&lt;/beans&gt; sqlMapConfig.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--加载properties文件--&gt; &lt;properties resource=\"jdbc.properties\" /&gt; &lt;!--定义别名--&gt; &lt;typeAliases&gt; &lt;!--通过扫包自动定义别名--&gt; &lt;package name=\"top.rainbowcat.domain\" /&gt; &lt;package name=\"top.rainbowcat.mapper\" /&gt; &lt;!--该方法只对需要的实体创建别名--&gt; &lt;!--&lt;typeAlias type=\"top.rainbowcat.domain.Account\" alias=\"account\" /&gt;--&gt; &lt;/typeAliases&gt; &lt;!--配置环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射--&gt; &lt;mappers&gt; &lt;!--单独加载--&gt; &lt;!--&lt;mapper resource=\"top.rainbowcat.mapper.AccountMapper\" /&gt;--&gt; &lt;!--自动扫包--&gt; &lt;package name=\"top.rainbowcat.mapper\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; jdbc.properties 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=GMTjdbc.username=rootjdbc.password=password log4j.properties 12345log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.errlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.ConversionPattern=%d&#123;ABSOLUTE&#125;%5p%c&#123;1&#125;:%L - %m%nlog4j.rootLogger=all, stdout mybatis整合spring使用spring来产生mapper并存入容器，在使用时直接从容器当中获取。applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=\"top.rainbowcat\"&gt; &lt;!--排除controller的扫描--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!--加载properties文件--&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt; &lt;!--配置数据源信息--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt; &lt;!--配置sessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"configLocation\" value=\"classpath:sqlMapConfig.xml\" /&gt; &lt;/bean&gt; &lt;!--加载mapper映射，创建mapper实现类--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"top.rainbowcat.mapper\" /&gt; &lt;/bean&gt;&lt;/beans&gt; sqlMapConfig.xml： 12 service层： 12345678910111213141516@Service(\"/accountService\")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountMapper accountMapper; @Override public void save(Account account) &#123; accountMapper.save(account); &#125; @Override public List&lt;Account&gt; findAll() &#123; return accountMapper.findAll(); &#125;&#125; spring整合事务控制需要在applicationContext.xml当中添加如下配置信息： 123456789101112131415&lt;!--声明式事务控制--&gt;&lt;!--平台事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt;&lt;!--配置事务增强--&gt;&lt;tx:advice id=\"txAdvice\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--事务的aop织入--&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* top.rainbowcat.service.impl.*.*(..))\" /&gt;&lt;/aop:config&gt;","tags":[]},{"title":"Mybatis学习","date":"2020-09-21T08:29:01.000Z","path":"2020/09/21/Mybatis学习/","text":"为什么要使用Mybatis原始jdbc开发存在的问题如下:①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能②sql语句在代码中硬编码,造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置应对.上述问题给出的解决方案:①使用数据库连接池初始化连接资源②将sql语句抽取到xm配置文件中③使用反射、内省等底层技术,自动将实体与表进行属性与字段的自动映射 ●mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc, 使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。●mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。●最后mybati框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api底层访问细节,使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。 开发步骤：①添加MyBatis的坐标②创建user数据表③编写User实体类④编写映射文件UserMapper.xml⑤编写核心文件SqlMapConfig.xml⑥编写测试类 入门案例：导入坐标（Maybits、MySQL） 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt;&lt;/dependency&gt; 创建实体类user编写映射mapper文件 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.orq/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- 命名空间 --&gt;&lt;mapper namespace=\"userMapper\"&gt; &lt;!-- 命名空间结合id为访问标识 方便调用 --&gt; &lt;!-- resultType：查询结果对应的实体类型，方便mybatis进行封装 --&gt; &lt;select id=\"findAll\" resultType=\"top.rainbowcat.domain.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 编写核心SqlMapConfig文件 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 数据源环境 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/jsp?serverTimezone=GMT\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"top/rainbowcat/mapper/UserMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 简单测试： 12345678910111213141516171819202122232425262728import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MybatisTest &#123; @Test public void test() throws IOException &#123; //获取核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); //获得session工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); //获得session会话对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //执行操作 参数：namespace+id List&lt;Object&gt; userList = sqlSession.selectList(\"userMapper.findAll\"); //打印数据 System.out.println(userList); //释放资源 sqlSession.close(); &#125;&#125; Mybatis增删改操作：插入数据：需要注意的是，mybatis的占位符的不是“?”！Sq|语句中使用#(实体属性名)方式引用实体中的属性值 1234&lt;!--参数对象--&gt;&lt;insert id=\"save\" parameterType别名=\"top.rainbowcat.domain.Student\"&gt; insert into student values(#&#123;sno&#125;, #&#123;sname&#125;, #&#123;ssex&#125;, #&#123;sage&#125;, #&#123;sdept&#125;);&lt;/insert&gt; Mybatis执行更新操作需要提交事务（默认不提交）！在映射文件中使用parameterType属性指定要插入的数据类型插入操作使用的API是sqlSession.insert(“命名空间id”,实体对象);插入操作涉及数据库数据变化，所以要使用sqISession对象显示的提交事务, 1234567891011121314151617181920@Testpublic void test() throws IOException &#123; //模拟数据对象 Student student = new Student(); student.setSno(\"201211111\"); student.setSname(\"测试\"); student.setSsex(\"男\"); student.setSage(20); student.setSdept(\"AA\"); //获取核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); sqlSession.insert(\"userMapper.save\", student); //Mybatis执行更新操作需要提交事务（默认不提交） sqlSession.commit(); sqlSession.close();&#125; 数据更新： 123&lt;update id=\"update\" parameterType=\"top.rainbowcat.domain.Student\"&gt; update student set sname=#&#123;sname&#125;, ssex=#&#123;ssex&#125;, sage=#&#123;sage&#125;, sdept=#&#123;sdept&#125; where sno=#&#123;sno&#125;;&lt;/update&gt; 删除数据： 1234&lt;!-- 单一条件可以直接写数据类型 --&gt;&lt;delete id=\"delete\" parameterType=\"java.lang.String\"&gt; delete from student where sno=#&#123;sno&#125;;&lt;/delete&gt; Mybatis核心配置文件、MyBatis核心配置文件层级关系configuration配置 properties属性 实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件, 该标签可以加载额外配的properties文件 settings设置 typellases类型别名 3. typeHandlers类型处理器4. objectFactory对象工厂5. plugins插件6. environments环境 - environment 环境变量 - transactionManager 事务管理器 - dataSource 数据源其中，事务管理器(transactionManager) 类型有两种:●JDBC:这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。●MANAGED:这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期(比如JEE应用服务器的上下文)。默认情况下它会关闭连接,然而一些容器并不希望这样，此需要将closeConnection属性设置为false来阻止它默认的关闭行为。其中，数据源(dataSource) 类型有三种:●UNPOOLED: 这个数据源的实现只是每次被请求时打开和关闭连接。●POOLED:这种数据源的实现利用“池”的概念将JDBC连接对象组织起来。●JNDI: 这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI上下文的引用。 databaseldProvider数据库厂商标识 mappers映射器 该标签的作用是加载映射的，加载方式有如下几种: 1234●使用相对于类路径的资源引用，例如: &lt;mapper resource&#x3D; *org&#x2F;mybatis&#x2F;builder&#x2F;AuthorMapper.xml&quot;&#x2F;&gt;●使用完全限定资源定位符 (URL), 例如:&lt;mapper ur&#x3D;&#x2F;le&#x2F;&#x2F;mappers&#x2F;AuthorMapperxmn&quot;&#x2F;&gt;●使用映射器接口实现类的完全限定类名，例如: &lt;mapper class&#x3D;&quot;org.mybatis builder.AuthorMapper*&#x2F;&gt;●将包内的映射器接口实现全部注册为映射器，例如: &lt;package name&#x3D;&quot;org.mybatis builder*&#x2F;&gt; 1234567891011121314151617181920&lt;configuration&gt; &lt;!-- 数据源环境 --&gt; &lt;properties resource=\"jdbc.properties\"/&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"top/rainbowcat/mapper/UserMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; Mybatis相关APISqlSession工厂构建器SqlSessionFactoryBuilder常用API: Sq|SessionF actory build(InputStream inputStream)通过加载mybatis的核心文件的输入流的形式构建一个SqISessionF actory对象 12345//获取核心配置文件resource = \"xml配置文件的路径（相对于类加载路径）\";InputStream inputStream = Resources.getResourceAsStream(resource);//获得session工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 其中，Resources工具类，这个类在org.apache.ibatis.io包中。Resources类帮助你从类路径下、文件系统或一个web URL中加载资源文件。 SqlSession工厂对象SqlSessionFactorySqlsessionFactory有多个个方法创建Sqlession实例。常用的有如下两个: 方法 说明 openSession() 会默认开启一个事务，但事务不会自动提交，也就意味着需要手动提交该事务，更新操作数据才会持久化到数据库中 openSession(boolean autoCommit) 参数为是否自动提交，如果设置为true,那么不需要手动提交事务 SqlSession会话对象SqlSession实例在MyBatis中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。执行语句的方法主要有: 12345&lt;T&gt; T selectOne(String statement, Object parameter)&lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter)int insert (String statement, Object parameter)int uodate (String statement, Object parameter)int delete (String statement, Object parameter) 操作事务的方法主要有： 12void commit()void rollback() 示例： 123&lt;select id=\"findBySno\" resultType=\"string\"&gt; select * from student where sno=#&#123;sno&#125;&lt;/select&gt; 1Student student = sqlSession.selectOne(\"userMapper.findBySno\", \"201211111\"); Mybatis的Dao层实现传统开发方式使用传统的dao写法即可(接口)： 12345678910public class StudentMapperImpl implements StudentMapper &#123; @Override public List&lt;Student&gt; findAll() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;Student&gt; studentList = sqlSession.selectList(\"userMapper.findAll\"); return studentList; &#125;&#125; 代理开发方式采用Mybatis的代理开发方式实现DAO层的开发，这种方式是我们后面进入企业的主流。Mapper接口开发方法只需要程序员编写Mapper接口(相当于Dao接口) ,由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同边Dao接口实现类方法。Mapper接口开发需要遵循以下规范: Mapper.xml文件中的namespace 与mapper接口的全限定名相同 Mapper接口方法名和Mapper.xml中定义的每 个statement的id相同 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sq|的parameterType的类型相同 Mapper接口方法的输出参数类型和mapper.xml中定义的每 个sql的resultType的类型相同mapper.xml文件中：12345&lt;mapper namespace=\"top.rainbowcat.dao.StudentMapper\"&gt; &lt;select id=\"findAll\" resultType=\"top.rainbowcat.domain.Student\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 采用该方法，接口不需要手动实现。123456789@Testpublic void test() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); List&lt;Student&gt; studentList = mapper.findAll(); System.out.println(studentList);&#125; MyBatis映射文件深入动态sq|语句动态sq|语句概述Mybatis的映射文件中，前面我们的SQL都是比较简单的，有些时候业务逻辑复杂时，我们的SQL是动态变化的，比时在前面的学习中我们的SQL就不能满足要求了。 if 使用Myatis的动态查询语句,会自动判断参数并拼接sql语句。只有在符合条件的情况下，才会进行拼接。 12345678910111213141516&lt;mapper namespace=\"top.rainbowcat.dao.StudentMapper\"&gt; &lt;select id=\"findByCondition\" resultType=\"top.rainbowcat.domain.Student\" parameterType=\"top.rainbowcat.dao.StudentMapper\"&gt; select * from student &lt;where&gt; &lt;if test=\"sno!=null\"&gt; and sno=#&#123;sno&#125; &lt;/if&gt; &lt;if test=\"sdept!=null\"&gt; and sdept=#&#123;sdept&#125; &lt;/if&gt; &lt;if test=\"ssex!=null\"&gt; and ssex=#&#123;ssex&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; choose (when, otherwise) trim (where,set) foreach123456789&lt;select id=\"findBySno\" resultType=\"student\" parameterType=\"studentMapper\"&gt; select * from student &lt;where&gt; &lt;!--collection：传递的参数类型--&gt; &lt;foreach collection=\"list\" open=\"sno in (\" close=\")\" item=\"sno\" separator=\",\"&gt; #&#123;sno&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 1234List&lt;String&gt; list = new ArrayList&lt;String &gt;();list.add(\"201215004\");StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);List&lt;Student&gt; student = mapper.findBySno(list); sql语句的抽取抽取前： 123456&lt;select id=\"findBySno\" resultType=\"student\" parameterType=\"studentMapper\"&gt; select * from student &lt;where&gt; &lt;!-- 条件 --&gt; &lt;/where&gt;&lt;/select&gt; 抽取后： 1234567&lt;sql id=\"selectStudent\"&gt;select * from student&lt;/sql&gt;&lt;select id=\"findBySno\" resultType=\"student\" parameterType=\"studentMapper\"&gt; &lt;include refid=\"selectStudent\"&gt;&lt;/include&gt; &lt;where&gt; &lt;!-- 条件 --&gt; &lt;/where&gt;&lt;/select&gt; sql语句的抽取方便后期代码的维护，在修改sql语句时，能够减少修改的次数，大大提高维护效率。 Mybatis核心配置文件深入typeHandlers标签无论是MyBatis在预处理语句(PreparedStatement) 中设置一个参数时, 还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换成Java类型。下表描述了-些默认的类型处理器(截取部分)。 类型处理器 Java类型 JDBC类型 BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的BOOLEAN ByteTypeHandler java.lang.Byte, byte 数据库兼容的NUMERIC或BYTE ShortTypeHandler java.lang.Short.short 数据库兼容的NUMERIC或SHORT INTEGER IntegerTypeHandler java.lang.Integer，int 数据库兼容的NUMERIC或INTEGER LongTypeHandler Java.lang.Long.long 数据库兼容的NUMERIC或LONG INTEGER 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为:实现 org.apache.ibatis.type.TypeHandler接口，或继承-个很便利的类 org.apace.ibatis.type.BaseTypeHandler,然后可以选择性地将它映射到一个JDBC类型。 例如需求: 一个Java中的Date数据类型,我想将之存到数据库的时候存成一 个1970年至今的毫秒数，取出来时转换成java的Date, 即java的Date 与数据库的varchar毫秒值之间转换。 开发步骤: 1. 定义转换类继承类BaseTypeHandler 2. 覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法， getNullableResult为查询时mysql的字符串类型转换成java的Type类型的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package top.rainbowcat.handler;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Date;public class DateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; /** * 将java转换为数据库需要的类型 * @param preparedStatement 设置参数 * @param i 参数的位置 * @param date * @param jdbcType * @throws SQLException */ @Override public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType jdbcType) throws SQLException &#123; //获取毫秒值 long time = date.getTime(); //进行转换 preparedStatement.setLong(i, time); &#125; /** * 将数据库中某些数据类型转换为java类型 * @param resultSet 查询到的结果集 * @param s 数据库中要转的字段名称 * @return * @throws SQLException */ @Override public Date getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; //获取结果集中所需要的数据 long aLong = resultSet.getLong(s); Date date = new Date(aLong); return date; &#125; /** * 将数据库中某些数据类型转换为java类型 * @param resultSet * @param i * @return * @throws SQLException */ @Override public Date getNullableResult(ResultSet resultSet, int i) throws SQLException &#123; long aLong = resultSet.getLong(i); Date date = new Date(aLong); return date; &#125; /** * 将数据库中某些数据类型转换为java类型 * @param callableStatement * @param i * @return * @throws SQLException */ @Override public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123; long aLong = callableStatement.getLong(i); Date date = new Date(aLong); return date; &#125;&#125; 3. 在MyBatis核心配置文件中进行注册 1234&lt;!--自定义类型处理器--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=\"top.rainbowcat.handler.DateTypeHandler\"&gt;&lt;/typeHandler&gt;&lt;/typeHandlers&gt; 4. 测试转换是否正确 12345678910111213141516171819202122232425262728293031323334353637/** * 添加测试 * @throws IOException */@Testpublic void test() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setUsername(\"测试2\"); user.setPassword(\"123\"); user.setBirthday(new Date()); mapper.add(user); sqlSession.commit(); sqlSession.close();&#125; /** * 查询测试 * @throws IOException */@Testpublic void test2() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.findById(2); System.out.println(user.getBirthday()); sqlSession.commit(); sqlSession.close();&#125; plugins标签MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装,使用简单的方式即可获得分页的相关数据开发步骤: 导入通用PageHelper的坐标1234567891011&lt;!--分页助手插件--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt;&lt;/dependency&gt; 在mybatis核心配置文件中配置PageHelper插件123456&lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!--指定方言参数：不用数据库的结构化查询语句不同--&gt; &lt;!-- &lt;property name=\"dialect\" value=\"mysql\"/&gt; --&gt; &lt;/plugin&gt;&lt;/plugins&gt; 注意： pageHelper是如何在mybatis中是通过mybatis的pulgin实现了Interceptor接口，从而获得要执行的sql语句实现分页技术，而我们的PageHelper5.0.0版本中的这个类，并没有出现implements Interceptor，需要使用pagehelper这个包下的PageInterceptor类。 在PageHelper插件4.0.0以后的版本支持自动识别使用的数据库，可以不用配置 测试分页数据获取12345678910111213141516171819202122232425262728@Testpublic void test() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); //设置分页相关参数 当前页、每页显示数量 PageHelper.startPage(1, 5); List&lt;Student&gt; studentList = mapper.findAll(); for (Student student : studentList) &#123; System.out.println(student); &#125; //获得分页相关参数 PageInfo&lt;Student&gt; pageInfo = new PageInfo&lt;Student&gt;(studentList); System.out.println(\"当前页：\"+pageInfo.getPageNum()); System.out.println(\"每页显示条数：\"+pageInfo.getPageSize()); System.out.println(\"总条数：\"+pageInfo.getTotal()); System.out.println(\"总页数：\"+pageInfo.getPages()); System.out.println(\"上一页：\"+pageInfo.getNavigateLastPage()); System.out.println(\"是否是第一页：\"+pageInfo.isIsFirstPage()); sqlSession.commit(); sqlSession.close();&#125; Mybatis多表操作一对一查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于个用户一对一查询的需求:查询一个订单，与此同时查询出该订单所属的用户order实体类： 123456public class Order &#123; private int id; private String name; //当前订单属于哪个用户 private User user;&#125; OrderMapper配置文件： 12345678910111213141516171819202122232425262728293031323334&lt;mapper namespace=\"top.rainbowcat.dao.OrderMapper\"&gt; &lt;!--封装一个Map--&gt; &lt;resultMap id=\"orderMap\" type=\"order\"&gt; &lt;!-- 手动指定字段与实体属性的映射关系 column：字段 property：实体属性 此处使用oid时，sql语句中要有响应的别名oid --&gt; &lt;id column=\"oid\" property=\"id\" /&gt; &lt;result column=\"name\" property=\"name\" /&gt; &lt;!-- 可代替上下面的封装方式 property：当前实体（order）中属性名（private User user） javaType：当前实体中的属性类型（User），需要在朱配置文件中加别名 --&gt; &lt;association property=\"user\" javaType=\"user\"&gt; &lt;id column=\"id\" property=\"id\" /&gt; &lt;result column=\"username\" property=\"username\" /&gt; &lt;result column=\"password\" property=\"password\" /&gt; &lt;result column=\"birthday\" property=\"birthday\" /&gt; &lt;/association&gt; &lt;!--&lt;result column=\"uid\" property=\"user.id\" /&gt; &lt;result column=\"username\" property=\"user.username\" /&gt; &lt;result column=\"password\" property=\"user.password\" /&gt; &lt;result column=\"birthday\" property=\"user.birthday\" /&gt;--&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"orderMap\"&gt; select *, o.id oid from orders o, users u where o.uid=u.id &lt;/select&gt;&lt;/mapper&gt; 测试： 12345678910111213@Test public void test() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); OrderMapper mapper = sqlSession.getMapper(OrderMapper.class); List&lt;Order&gt; orders = mapper.findAll(); for (Order order : orders) &#123; System.out.println(order); &#125; sqlSession.commit(); sqlSession.close(); &#125; 一对多查询的模型user实体类： 123456789public class User &#123; private int id; private String username; private String password; private Date birthday; //当前用户存在哪些订单 private List&lt;Order&gt; orderList;&#125; UserMapper配置文件： 1234567891011121314151617181920212223&lt;mapper namespace=\"top.rainbowcat.dao.UserMapper\"&gt; &lt;resultMap id=\"userMap\" type=\"user\"&gt; &lt;id column=\"uid\" property=\"id\" /&gt; &lt;result column=\"username\" property=\"username\" /&gt; &lt;result column=\"password\" property=\"password\" /&gt; &lt;result column=\"birthday\" property=\"birthday\" /&gt; &lt;!-- 配置集合信息 property：集合名称 ofType：当前集合中的数据类型 --&gt; &lt;collection property=\"orderList\" ofType=\"order\"&gt; &lt;!--封装order的数据--&gt; &lt;id column=\"oid\" property=\"id\" /&gt; &lt;result column=\"name\" property=\"name\" /&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select *, u.id uid from users u, orders o where o.uid=u.id &lt;/select&gt;&lt;/mapper&gt; 多对多查询sql语句要从多个表中查询，查询条件也要注意。select * from user u, user_role ur, role r where u.id=ur.userId and ur.roleId=r.id Mybatis注解开发这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper映射文件了。我们先围绕-些基本的CRUD来学习, 再学习复杂映射多表操作。@Insert:实现新增@Update:实现更新@Delete:实现删除@Select:实现查询@Result:实现结果集封装@Results:可以与@Result-起使用， 封装多个结果集@One:实现一对一 结果集封装@Many:实现一对多结果集封装 mapper配置文件不需要写了，但是接口中要用注解进行映射，同时也要写sql语句。 12345public interface UserMapper &#123; @Select(\"select * from users\") public List&lt;User&gt; findAll();&#125; 核心配置文件中不需要分别加载映射文件： 1234567&lt;!--加载映射文件--&gt;&lt;mappers&gt; &lt;!--&lt;mapper resource=\"top/rainbowcat/mapper/UserMapper.xml\" /&gt;--&gt; &lt;!--&lt;mapper resource=\"top/rainbowcat/mapper/OrderMapper.xml\" /&gt;--&gt; &lt;!--只需要标注mapper配置文件所在的包--&gt; &lt;package name=\"top.rainbowcat.dao\"/&gt;&lt;/mappers&gt; MyBatis的注解实现复杂映射实现复杂关系映射之前我们可以在映射文件中通过配置resultMap来实现，使用注解开发后,我们可以使用@Results注解，@Result注解， @One注解，@Many注解组合完成复杂关系的配置 注解 说明 @Results 代替的是标签resultMap该注解中可以使用单个@Result注解，也可以使用@Result集合。使用格式: @Results({@Result()，@Result()}) 或@Results (@Result()) @Resut 代替了id标签和result标签 @Result中属性介绍: column:数据库的列名 @Resut property:需要装配的属性名 one:需要使用的@One注解(@Result (one= @One) () ) ) many:需要使用的@Many注解(@Result (many=@many) () ) ) @One (一对一) 代替了assocation标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。 select:指定用来多表查询的sqlmapper @One注解属性介绍: 使用格式: @Result(column=\"\",property=\",one= @One(select=*\")) @Many (多对一)·· 代替了collection标签是是多表查询的关键，在注解中用来指定子查询返回对象集合。 使用格式: @Result(property=\",column=\",many= @Many(select=\")) 一对一注解开发：以用户订单案例进行分析，查询某一订单对应的用户时，一个订单只能一个用户，所以在封装数据时，除了order的数据，还要封装user的实体对象数据。第一种封装方式 12345678910111213public interface OrderMapper &#123; @Select(\"select *, o.id oid from orders o, users u where o.uid=u.id\") @Results(&#123; @Result(column = \"oid\", property = \"id\"), @Result(column = \"name\", property = \"name\"), @Result(column = \"uid\", property = \"user.id\"), @Result(column = \"username\", property = \"user.username\"), @Result(column = \"password\", property = \"user.password\"), @Result(column = \"birthday\", property = \"user.birthday\"), &#125;) public List&lt;Order&gt; findAll();&#125; 第二种封装方式 1234567891011121314public interface OrderMapper &#123; @Select(\"select *, o.id oid from orders o, users u where o.uid=u.id\") @Results(&#123; @Result(column = \"oid\", property = \"id\"), @Result(column = \"name\", property = \"name\"), @Result( property = \"user\", //要封装的属性名称 javaType = User.class, //要封装的实体类型 column = \"uid\", //根据那个字段去查询（此处为orders表中的uid查询user表中的id） one = @One(select = \"top.rainbowcat.dao.UserMapper.findById\") ) &#125;) public List&lt;Order&gt; findAll();&#125; 一对多注解开发相比一对一的数据封装，多对多封装的不再是一个实体对象，而是实体对象的list集合。仍以用户订单为例，一个用户可以有多个订单，于是查询某个用户的订单时，需要封装订单集合。需要在OrderMapper接口中添加根据订单id查询列表的方法： 12@Select(\"select * from orders where uid=#&#123;uid&#125;\")public List&lt;Order&gt; findByUid(int uid); UserMapper接口中的方法： 1234567891011121314@Select(\"select* from users\")@Results(&#123; @Result(column = \"id\", property = \"id\"), @Result(column = \"username\", property = \"username\"), @Result(column = \"password\", property = \"password\"), @Result(column = \"birthday\", property = \"birthday\"), @Result( property = \"orderList\", column = \"id\", javaType = List.class, many = @Many(select = \"top.rainbowcat.dao.OrderMapper.findByUid\") )&#125;)public List&lt;User&gt; findUserAndOrder(); 多对多查询的模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用多对多查询的需求:查询用户同时查询出该用户的所有色（主要区别就是多了中间表）实体类： 12345678public class User &#123; private int id; private String username; private String password; private Date birthday; //当前用户具备的角色 private List&lt;Role&gt; roleList;&#125; mapper接口： 1234567891011121314@Select(\"select * from user\")@Results(&#123; @Result(id = true, column = \"id\", property = \"id\"), @Result(column = \"username\", property = \"username\"), @Result(column = \"password\", property = \"password\"), @Result(column = \"birthday\", property = \"birthday\"), @Result( column = \"id\", property = \"roleList\", javaType = List.class, many = @Many(select = \"top.rainbowcat.dao.RoleMapper.findByUid\") )&#125;)public List&lt;User&gt; findUserAndRole(); 123456public interface RoleMapper &#123; //最后的and部分，是保证查询单个用户的角色 @Select(\"select * from sys_user_role ur, sys_role r where ur.roleId=r.id and ur.userId=#&#123;uid&#125;\") public List&lt;Role&gt; findByUid(int uid);&#125;","tags":[]},{"title":"Spring MVC","date":"2020-07-30T06:01:26.000Z","path":"2020/07/30/Spring MVC/","text":"Spring集成Web环境环境集成maven集成tomcat8插件（非官方）：首先要在tomcat-users.xml的文件中加入： 1&lt;user username=\"tomcat\" password=\"tomcat\" roles=\"manager-gui,manager-script\" /&gt; 然后在maven本地仓库的settings.xml中加入： 1234567&lt;pluginGroup&gt;org.apache.tomcat.maven&lt;/pluginGroup&gt;&lt;server&gt; &lt;id&gt;tomcat8&lt;/id&gt; &lt;username&gt;tomcat&lt;/username&gt; &lt;password&gt;tomcat&lt;/password&gt;&lt;/server&gt; 然后就可以在maven项目的pom.xml中使用tomcat插件： 12345678910111213&lt;!--tomcat8插件--&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;url&gt;http://127.0.0.1:8080/manager/text&lt;/url&gt; &lt;server&gt;tomcat8&lt;/server&gt; &lt;port&gt;80&lt;/port&gt; &lt;!-- 项目的虚拟路径 --&gt; &lt;path&gt;/test&lt;/path&gt; &lt;/configuration&gt;&lt;/plugin&gt; pom.xml中添加坐标，集成web环境：123456789101112&lt;!--servlet--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--jsp--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt;&lt;/dependency&gt; ApplicationContext应用上下文获取方式 应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件)方式获取的，但是每次从 容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ,这样的弊端是配置 文件加载多次，应用上下文对象创建多次。&lt;br&gt; 在Web项目中，可以使用ServletContextListener监听Web应用的启动， 我们可以在Web应用启动时，就加 载Spring的配置文件，创建应用上下文对象ApplicationContext,在将其存储到最大的域servletContext域 中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。 不使用spring的实现方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** *上下文初始化监听，也即是服务器启动时 */public class ContextLoaderListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; ServletContext servletContext = sce.getServletContext(); //从web.xml中获取配置文件 String contextConfigLocation = servletContext.getInitParameter(\"contextConfigLocation\"); ApplicationContext app = new ClassPathXmlApplicationContext(contextConfigLocation); //将Spring的应用上下文对象存储到ServletContext域中 servletContext.setAttribute(\"app\", app); System.out.println(\"Spring容器创建完毕....\"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; &#125;&#125;public class WebApplicationContextUtils &#123; /** * 返回applicationContext容器对象 * @param servletContext * @return */ public static ApplicationContext getApplicationContext(ServletContext servletContext)&#123; return (ApplicationContext) servletContext.getAttribute(\"app\"); &#125;&#125;@WebServlet(\"/userServlet\")public class UserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ApplicationContext applicationContext = WebApplicationContextUtils.getApplicationContext(request.getServletContext()); System.out.println(applicationContext); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 1234567&lt;listener&gt; &lt;listener-class&gt;top.rainbowcat.listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; spring提供获取应用上下文的工具Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中, 提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。使用步骤： 在web.xml中配置ContextLoaderListener监听器(导入spring-web坐标) 使用WebApplicationContextUtils获得应用上下文对象ApplicationContext 首先需要导入坐标： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; web层获取方式： 12345678910111213@WebServlet(\"/userServlet\")public class UserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext servletContext = request.getServletContext(); ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext); System.out.println(applicationContext); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 用spring进行配置，自动生成： 123456789&lt;!--配置监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置全局初始化参数--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; Spring MVCSpringMVC是-种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow中。SpringMVC已经成为目前最主流的MVC框架之一,并且随着Spring3.0 的发布，全面超越Struts2,成为最优秀的MVC框架。它通过一套注解, 让-个简单的Java类成为处理请求的控制器,而无须实现任何接口。同时它还支持RESTful编程风格的请求。 开发步骤- 导入SpringMVC相关坐标 - 配置SpringMVC核心控制器DispatcherServlet - 创建Controller类和视图页面 - 使用注解配置Controller类中业务方法的映射地址 - 配置SpringMVC核心文件spring-mvc.xml - 客户端发起请求测试导入相关坐标： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在web.xml中配置SpringMVC核心控制器DispatcherServlet： 12345678910111213141516171819202122232425&lt;!--配置springMVC前端控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-MVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--服务器启动时加载--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;!--此处用 / 会导致所有请求资源都要经过这里，会把响应的资源也拦截--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--放行.jsp、.html文件--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 创建Controller类和视图页面，并使用注解进行配置 12345678910@Controllerpublic class UserController &#123; @RequestMapping(\"/userSave\") public String save()&#123; System.out.println(\"测试...\"); //此处的返回值，前面省略了redirect（重定向前缀）或forward（转发）。如：forward:/demo.jsp return \"demo.jsp\"; &#125;&#125; 配置spring-MVC.xml文件，开启组件扫描 12&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=\"top.rainbowcat.controller\" /&gt; SpringMVC组件解析 SpringMVC的执行流程 用户发送请求至前端控制器DispatcherServlet, DispatcherServlet收到请求调用HandlerMapping处理器映射器。 处理器映射器找到具体的处理器(可以根据xm|配置、注解进行查找), 生成处理器对象及处理器拦截器(如果有则生成)-井返回给DispatcherServlet, DispatcherServlet调用HandlerAdapter处理器适配器。 HandlerAdapter经过适配调用具体的处理器(Controller,叫后端控制器)。 Controller执行完成返回ModelAndView, HandlerAdapter将controller执行结果ModelAndView返回给DispatchersServlet. DispatcherServlet将ModelAndView传给ViewResolver视图解析器。 ViewResolver解析后返回具体View. DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)。DispatcherServlet响应用户。 SpringMVC注解解析 @RequestMapping作用:用于建立请求URL和处理请求方法之间的对应关系位置: - 类上， 请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录 - 方法上， 请求URL的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径 属性: - value:用于指定请求的URL。它和path属性的作用是一样的 - method:用于指定请求的方式 - params:用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模-样 - params = {“accountName”),表示请求参数必须有accountName - params = {“money!100”),表示请求参数中money不能是100 1@RequestMapping(value = \"/save\", method = RequestMethod.GET) spring的XML解析springMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties,该文件中配置了默认的视图解析器，如下: org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver 翻看该解析器源码，可以看到该解析器的默认设置，如下: 1234REDIRECT_URL_PREFIX=\"redirect:\" --重定向前缀FORWARD_URL_PREFIX =\"forward:\" --转发前缀(默认值)prefix = \"\"; --视图名称前缀suffix = \"\"; --视图名称后缀 在spring-MVC.xml当中配置内部资源视图解析器后，controller当中的返回值就可以简写： 12345678&lt;!--配置内部资源视图解析器--&gt;&lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--最终的地址为：/jsp/demo.jsp--&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/jsp/\" &gt;&lt;/property&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt; return “demo”; //不需要写资源路径的前缀和扩展名 SpringMVC数据响应SpringMVC数据响应方式页面跳转 直接返回字符串：此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转。 通过ModelAndView对象返回： 1234567891011121314/** * Model：模型，用于封装数据 * View：视图，用于展示数据 * @return */@RequestMapping(\"/test\")public ModelAndView test()&#123; ModelAndView modelAndView = new ModelAndView(); //设置模型数据 modelAndView.addObject(\"msg\", \"测试ModelAndView...\"); //设置视图名称 modelAndView.setViewName(\"demo\"); return modelAndView;&#125; 也可以使用可传参的方式，方便使用注入： 12345678@RequestMapping(\"/test\")public ModelAndView test(ModelAndView modelAndView)&#123; //设置模型数据 modelAndView.addObject(\"msg\", \"测试ModelAndView...\"); //设置视图名称 modelAndView.setViewName(\"demo\"); return modelAndView;&#125; 也可以将ModelAndView进行拆分： 12345@RequestMapping(\"/test\")public String test(Model model)&#123; model.addAttributeName(\"msg\", \"测试ModelAndView...\"); return \"demo\";&#125; 此处的Model也可以是HttpServletRequest（是形参，在使用时由框架创建），使用request。 回写数据 直接返回字符串 通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”)回写数据，此时不需要视图跳转，业务方法返回值为void, 将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回。 直接使用response回写： 1234@RequestMapping(\"/response\")public void response(HttpServletResponse response) throws IOException &#123; response.getWriter().print(\"hello world\");&#125; 使用@ResponseBody注解: 12345@RequestMapping(value = \"/save\", method = RequestMethod.GET)@ResponseBody //告知springMVC框架，直接进行数据响应而不是资源跳转public String save()&#123; return \"test...\";&#125; 返回对象或集合： 使用Jackson将返回值转为json对象： 12345678@RequestMapping(value = \"/save\", method = RequestMethod.GET)@ResponseBodypublic String save() throws JsonProcessingException &#123; User user = new User(); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(user); return json;&#125; 使用springMVC自动转换为json对象： 12345678@RequestMapping(value = \"/save\", method = RequestMethod.GET)@ResponseBodypublic User save() &#123; User user = new User(); user.setName(\"lisi\"); user.setAge(20); return user;&#125; xml配置方式spring-MVC.xml 123456789&lt;!--配置消息转换器--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;!--配置jackson的转换器--&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 在方法上添加@ResponseBody就可以返回son格式的字符串,但是这样配置比较麻烦,配置的代码比较多,因此，我们可以使用mvc的注解驱动代替上述配置。注解方式 &lt;mvc:annotation-driven/&gt; SpringMVC获得请求数据客户端请求参数的格式是: name=value&amp;name=value…服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数: 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 基本类型参数Controller中的业务方法的参数名称要与请求参数的name一致, 参数值会自动映射匹配。例如：客户端请求为 http://localhost/spring/user/save?username=lisi&amp;age=18 123456@RequestMapping(\"/save\")@ResponseBodypublic void save(String username, int age) &#123; System.out.println(username); System.out.println(age);&#125; POJO类型参数Controller中的业务方法的POJO参数的属性名与请求参数的name一致, 参数值会自动映射匹配。（与实体类去匹配） 123456 @RequestMapping(\"/save\") @ResponseBody public void save(User user) &#123; System.out.println(user); &#125;//此外还需要有一个对应的实体类 数组类型参数Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配例如：客户端请求为 http://localhost/spring/user/save?str=aaa&amp;str=bbb&amp;str=ccc 123456@RequestMapping(\"/save\")@ResponseBodypublic void save(String[] str) &#123; //数组类型默认打印地址，转成集合方便查看 System.out.println(Arrays.asList(str));&#125; 集合类型参数获得集合参数时，要将集合参数包装到一个POJO中才可以。 1234567&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/save\"&gt; &lt;input type=\"text\" name=\"userList[0].name\"&gt;&lt;br&gt; &lt;input type=\"text\" name=\"userList[0].age\"&gt;&lt;br&gt; &lt;input type=\"text\" name=\"userList[1].name\"&gt;&lt;br&gt; &lt;input type=\"text\" name=\"userList[1].age\"&gt;&lt;br&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 12345@RequestMapping(\"/save\")@ResponseBodypublic void save(VO vo) &#123; System.out.println(vo);&#125; 当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POIO进行包装。 1234567891011121314&lt;script src=\"js/jquery-3.1.1.jar\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var userList = new Array(); userList.push(&#123;name: \"zhangsan\", age: 18&#125;); userList.push(&#123;name: \"lisi\", age: 20&#125;); $.ajax(&#123; type: \"POST\", url: \"/user/save\", data:JSON.stringify(userList), contentType: \"json\" &#125;); &#125;); &lt;/script&gt; 需要在spring-MVC.xml配置静态资源权限 1&lt;mvc:resources mapping=\"/js/**\" location=\"/js/\" /&gt; 12345@RequestMapping(\"/save\")@ResponseBodypublic void save(@RequestBody List&lt;User&gt; userList) &#123; System.out.println(userList);&#125; 静态资源访问的开启方式一： 12&lt;!--开放静态资源访问权限--&gt;&lt;mvc:resources mapping=\"/js/**\" location=\"/js/\" /&gt; 方式二： 1&lt;mvc:default-servlet-handler /&gt; 请求数据乱码问题当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。在web.xml中进行配置： 12345678910111213&lt;!--配置全局过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 参数绑定注解@requestParam当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定。例如：页面提交的是&lt;input type=&quot;text&quot; name=&quot;lisi&quot;&gt;，controller当中可以写成：public void save(@RequestParam(&quot;name&quot;)String username)。注解@RequestParam还有如下参数可以使用: value: 与请求参数名称 required: 此在指定的请求参数是否必须包括，默认是true, 提交时如果没有此参数则报错 defaultValue: 当没有指定请求参数时，则使用指定的默认值赋值 1public void save(@RequestParam(value = \"name\", required = false, defaultValue = \"rainbow\")String username) 当页面提交时，没有附带name参数，则不会报请求错误，使用默认值“rainbow”。 获得Restful风格的参数Restful是一种软件架构风格、 设计风格,而不是标准，只是提供了一组设计原则和约束条件。 主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。Restful风格的请求是使用url+ 请求方式表示-次请求目的的，HTTP 协议里面四个表示操作方式的动词如下: GET:用于获取资源 POST:用于新建资源 PUT:用于更新资源 DELETE:用于删除资源 例如： /user/1 GET 得到id= 1的user /user/1 DELETE 删除 id= 1的user /user/1 PUT 更新id= 1的user /user POST 新增user 上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id};占位符(id)对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行 占位符的匹配获取工作。 http://localhost/spring/user/save/zhangsan 12345@RequestMapping(\"/save/&#123;name&#125;\")@ResponseBodypublic void save(@PathVariable(value = \"name\", required = true)String username) &#123; System.out.println(username);&#125; 此处的逻辑是：{name} –&gt; value=”name” –&gt; username 自定义类型转换器SpringMVC默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参 数设置。但是不是所有的数据类型都提供了转换器,没有提供的就需要自定义转换器，例如: 日期类型的数据就需要自定义转换器。自定义类型转换器的开发步骤: 定义转换器类实现Converter接口 在配置文件中声明转换器 在&lt;annotation- driven&gt;中引用转换器 123456789101112131415161718192021package top.rainbowcat.converter;import org.springframework.core.convert.converter.Converter;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class DateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String dateStr) &#123; //将日期字符串转换成日期对象 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = null; try &#123; date = sdf.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; 1234567891011&lt;!--声明自定义类型转换器--&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"top.rainbowcat.converter.DateConverter\" /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--配置消息转换器注解驱动--&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt; 12345@RequestMapping(\"/save\")@ResponseBodypublic void save(Date date) &#123; System.out.println(date);&#125; 获取请求头 @RequestHeader使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name)@RequestHeader注解的属性如下: value：请求头的名称 required：是否必须携带此请求头 @CookieValue.使用@CookieValue可以获得指定Cookie的值@CookieValue注解的属性如下: value: 指定cookie的名称 required: 是否必须携带此cookie 123456789@RequestMapping(\"/save\")@ResponseBodypublic void saveMethod(@RequestHeader(value = \"User-Agent\", required = false) String userAgent, @RequestHeader(value = \"Cookie\", required = false)String cookie) &#123; System.out.println(userAgent); System.out.println(cookie);&#125;//直接获取Cookie键为\"_ga\"的值public void saveMethod(@CookieValue(value = \"_ga\", required = false)String cookie) 文件上传文件上传客户端三要素 表单项type= “file” 表单的提交方式是post 表单的enctype属性是多部分表单形式，及enctype= “mutipart/form-data’ 文件上传原理 当form表单修改为多部分表单时，request.getParameter0将失效。 enctype= “application/x-wgww-form-urlencoded” 时, form表单的正文内容格式是:key=value&amp;key=value&amp;key=value 当form表单的enctype取值为Mutilpart/form-data时,请求正文内容就变成多部分形式: 单文件上传步骤 导入fileupload和io坐标 配置文件上传解析器 编写文件.上传代码 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 在spring-MVC.xml中： 123456789 &lt;!--配置文件上传解析器--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--上传文件的编码类型--&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\" /&gt; &lt;!--上传文件总大小--&gt; &lt;property name=\"maxUploadSize\" value=\"5242800\" /&gt; &lt;!--上传单个文件的大小--&gt; &lt;property name=\"maxUploadSizePerFile\" value=\"5242800\" /&gt;&lt;/bean&gt; 12345&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/save\" method=\"post\" enctype=\"multipart/form-data\"&gt; 名称：&lt;input type=\"text\" name=\"name\" &gt;&lt;br&gt; 文件：&lt;input type=\"file\" name=\"upload\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=上传\"&gt;&lt;/form&gt; 1234567@RequestMapping(\"/save\")@ResponseBodypublic void save(String name, MultipartFile upload) throws IOException &#123; //获得上传的文件名称 String originalFilename = upload.getOriginalFilename(); upload.transferTo(new File(\"\\\\文件存储路径\\\\\" + originalFilename));&#125; 需要注意的是：表单中name的值要和controller中的参数一致。 单文件上传步骤只需要在表单和controller中做修改： 123456&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/save\" method=\"post\" enctype=\"multipart/form-data\"&gt; 名称：&lt;input type=\"text\" name=\"name\" &gt;&lt;br&gt; 文件：&lt;input type=\"file\" name=\"upload1\"&gt;&lt;br&gt; 文件：&lt;input type=\"file\" name=\"upload2\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=上传\"&gt;&lt;/form&gt; 123456789@RequestMapping(\"/save\") @ResponseBody public void save(String name, MultipartFile upload1, MultipartFile upload2) throws IOException &#123; //获得上传的文件名称 String originalFilename1 = upload1.getOriginalFilename(); String originalFilename2 = upload2.getOriginalFilename(); upload1.transferTo(new File(\"\\\\文件存储路径\\\\\" + originalFilename1)); upload2.transferTo(new File(\"\\\\文件存储路径\\\\\" + originalFilename2)); &#125; 或者可以使用数组： 123文件1：&lt;input type=\"file\" name=\"upload\"&gt;&lt;br&gt;文件2：&lt;input type=\"file\" name=\"upload\"&gt;&lt;br&gt;文件3：&lt;input type=\"file\" name=\"upload\"&gt;&lt;br&gt; 12345678@RequestMapping(\"/save\")@ResponseBodypublic void save(String name, MultipartFile[] upload) throws IOException &#123; for (MultipartFile multipartFile : upload) &#123; String originalFilename = multipartFile.getOriginalFilename(); multipartFile.transferTo(new File(\"\\\\文件存储路径\\\\\" + originalFilename)); &#125;&#125; SpringMVC拦截器Spring MVC的拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。将拦截器按一定的顺序联结成一条链，这条链称为拦截器链(Interceptor Chain)。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。 拦截器和过滤器区别（比较重要） 区别 过滤器 拦截器 使用范围 是servlet规范中的一部分，任何Java Web工程都可以使用 是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能用 拦截范围 在url-pattern中配置了/*之后，可以对所有要访问的资源拦截 只会拦截访问的控制器方法，如果访问的是jsp,html,css,image或者js是不会进行拦截的 如何自定义拦截器 创建拦截器类实现HandlerInterceptor接口 配置拦截器 测试拦截器的拦截效果 方法名 说明 preHandle() 方法将在请求处理之前进行调用，该方法的返回值是布尔值Boolean类型的， 当它返回为false时，表示请求结束，后续的Interceptor和Controller都不会 再执行;当返回值为true时就会继续调用下一个Interceptor的preHandle方法 postHandle() 该方法是在当前请求进行处理之后被调用，前提是preHandle 方法的返回值为 true时才能被调用，且它会在DispatcherServlet 进行视图返回渲染之前被调 用，所以我们可以在这个方法中对Controller处理之后的ModelAndView对象 进行操作 afterCompletion() 该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图 之后执行，前提是preHandle 方法的返回值为true时才能被调用 拦截器： 123456789101112131415161718192021222324252627282930313233343536public class MyInterceptor implements HandlerInterceptor &#123; /** * 目标方法执行之前执行 * @param request 用于获取请求内容 * @param response * @param handler * @return 返回true，则放行；若返回false则被拦截 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"preHandle...\"); if (\"yes\".equals(request.getParameter(\"param\"))) &#123; return true; &#125;else &#123; request.getRequestDispatcher(\"/error.jsp\").forward(request, response); return false; &#125; &#125; /** *目标方法执行之后，视图返回之前执行 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; modelAndView.addObject(\"name\", \"rainbow\"); System.out.println(\"postHandle...\"); &#125; /** * 整个流程都执行完成后执行 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"afterCompletion...\"); &#125;&#125; 配置spring-mvc.xml: 123456789101112&lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;!--此处可以配置多个拦截器，需要创建相应的类--&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--对哪些资源不拦截--&gt; &lt;mvc:exclude-mapping path=\"/user/login\"/&gt; &lt;bean class=\"top.rainbowcat.interceptor.MyInterceptor\" /&gt; &lt;/mvc:interceptor&gt; &lt;!--若配置多个拦截器，先配置的先执行--&gt; &lt;/mvc:interceptors&gt; 123456789101112@Controllerpublic class TargetController &#123; @RequestMapping(\"/target\") public ModelAndView show()&#123; System.out.println(\"目标方法执行...\"); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"name\", \"lisi\"); modelAndView.setViewName(\"index\"); return modelAndView; &#125;&#125; SpringMVC异常处理异常处理的思路系统中异常包括两类:预期异常和运行时异常RuntimeException,前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。 系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图: 异常处理两种方式 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolverSpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置1234567891011&lt;!--配置简单映射异常处理器--&gt; &lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;!--默认错误视图--&gt; &lt;property name=\"defaultErrorView\" value=\"error\" /&gt; &lt;property name=\"exceptionMappings\"&gt; &lt;map&gt; &lt;!--此处配置异常类型和错误视图--&gt; &lt;entry key=\"java.lang.ClassCastException\" value=\"error\" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 实现Spring的异常处理接口HandlerExceptionResolver自定义自己的异常处理器 自定义异常处理器步骤 - 创建异常处理器类实现HandlerExceptionResolver - 配置异常处理器 - 编写异常页面 - 测试异常跳转 自己编写异常处理器： 12345678910111213141516//需要继承HandlerExceptionResolverpublic class MyExceptionResolver implements HandlerExceptionResolver &#123; /** * @param e 报异常的异常对象 * @return 要跳转的错误视图信息 */ @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; ModelAndView modelAndView = new ModelAndView(); //判断异常类型和要执行的操作 if (e instanceof ClassCastException)&#123; modelAndView.addObject(\"info\", \"类转换异常\"); &#125; return modelAndView; &#125;&#125; 在spring-mvc.xml进行配置： 12&lt;!--配置自定义异常处理器--&gt;&lt;bean class=\"top.rainbowcat.resolver.MyExceptionResolver\" /&gt;","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Spring","date":"2020-07-28T06:01:26.000Z","path":"2020/07/28/Spring/","text":"spring简介什么是springSpring是分层的Java SE/EE应用full stack轻量级开源框架,以IoC(Inverse Of Control:反转控制)和AOP(Aspect Oriented Programming:面向切面编程)为内核。 提供了展现层SpringMVC和持久层Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术,还能整合开源世界众多著名的第三方框架和类库,逐渐成为使用最多的Java EE企业应用开源框架。 spring的优势 方便解耦，简化开发通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP编程的支持通过Spring的AOP功能，方便进行面向切面编程,许多不容易用传统OOP实现的功能可以通过AOP轻松实现。 声明式事务的支持可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务管理,提高开发效率和质量。 方便程序的测试可以用非容器依赖的编程方式进行几乎所有的测试工作,测试不再是昂贵的操作，而是随手可做的事情。 方便集成各种优秀框架Spring对各种优秀框架(Struts、Hibermate、Hessian、Quartz等) 的支持。 降低JavaEE API的使用难度Spring对JavaEE API (如JDBC、JavaMail、 远程调用等)进行了薄薄的封装层，使这些API的使用难度大为降低。 Java源码是经典学习范例Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。 spring的体系结构Core Container Beans Core Context SpEl AOP Aspects instrumentation Messaging Data Access/instrumentation JDBC ORM OXM JMS Transactions Web WebStocket Servlet Web Portlet 开发步骤 Spring程序开发步骤①导入Spring开发的基本包坐标②编写Dao接口和实现类③创建Spring核心配置文件④在Spring配置文件中配置UserDaolmpl⑤使用Spring的API获得Bean实例 配置文件需要在resources目录下创建配置文件（一般为applicationContext.xml），使用Bren标签进行配置（无参构造）。 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"useDao\" class=\"top.rainbowcat.dao.Impl.UserDaoImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; 调用时，从spring的客户端中使用getBean方法获取 12ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");UserDao userDao = (UserDao) app.getBean(\"userDao\"); Bean标签范围配置cope：指对象的作用范围，取值如下： 取值范围 说明 singleton 默认值，单例的（容器中只存在一个对象）①在应用加载，创建容器时创建对象②只要容器在，对象就一直活着③当应用卸载，销毁容器时对象被销毁 prototype 多例的①当使用（getBean）对象时创建②只要对象在使用中，就一直活着③当对象长时间不用，会被Java的垃圾回收器回收 request WEB项目中，Spring创建的一个Bean对象，将对象存入request域中 session WEB项目中，Spring创建的一个Bean对象，将对象存入session域中 global session WEB项目中，应用在Portlet环境，如果没有Portlet环境那么globalSession相当于session 1bean id=\"useDao\" class=\"top.rainbowcat.dao.Impl.UserDaoImpl\" scope=\"singleton\"&gt;&lt;/bean&gt; Bean生命周期配置init-method：指定类中的初始化方法名称destroy-method：指定类中的销毁方法名称 1bean id=\"useDao\" class=\"top.rainbowcat.dao.Impl.UserDaoImpl\" init-method=\"接口中的方法\"&gt;&lt;/bean&gt; Bean实例化三种方式 无参构造方法实例化 bean id=”useDao” class=”top.rainbowcat.dao.Impl.UserDaoImpl”&gt; 工厂静态方法实例化 bean id=”useDao” class=”top.rainbowcat.factory.StaticFactory” factory-method=”getUserDao”&gt; 12345public class StaticFactory&#123; public static UserDao getUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 工厂实例方法实例化 bean id=”factory” class=”top.rainbowcat.factory.DynamicFactory”&gt;bean id=”useDao” factory-bean=”factory” factory-method=”getUserDao”&gt; 12345public class DynamicFactory&#123; public UserDao getUserDao()&#123; return new UserDaoImpl(); &#125;&#125; Bean的依赖注入因为UserService和UserDao都在Spring容器中，而最终程序直接使用的是UserService,所以可以在Spring容器中，将UserDao设置到UserService内部。 Bean的依赖注入概念依赖注入(Dependency Injection) :它是Spring框架核心IOC的具体实现。在编写程序时，通过控制反转，把对象的创建交给了Spring, 但是代码中不可能出现没有依赖的情况。I0C解耦只是降低他们的依赖关系，但不会消除。例如:业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系,在使用Spring之后,就让Spring来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 Bean的依赖注入方式 set方法123456789101112public class UserServiceImpl implements UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; 123456&lt;bean id=\"userDao\" class=\"top.rainbowcat.dao.Impl.UserDaoImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"userService\" class=\"top.rainbowcat.service.Impl.UserServiceImpl\"&gt; &lt;!--name是service当中的set方法的属性--&gt; &lt;!--ref是容器当中的id值,代表对象引用（注入普通数据类型时不能使用）--&gt; &lt;property name=\"userDao\" ref=\"userDao\"&gt;&lt;/property&gt;&lt;/bean&gt; 外部程序在使用service的时候，要使用容器当中的才能正常调用dao层。直接new出来的service对象，无法获取到容器当中注入给service的dao对象。 P命名空间注入：本质上也是set方法注入，但比上述set方法注入更加方便（主要体现在配置文件中）。 12345&lt;!--首先引入P命名空间--&gt;xmlns:p=\"http://www.springframework.org/schema/p\"&lt;bean id=\"userDao\" class=\"top.rainbowcat.dao.Impl.UserDaoImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"userService\" class=\"top.rainbowcat.service.Impl.UserServiceImpl\" p:userDao-ref=\"userDao\" /&gt; 构造方法1234567891011121314151617public class UserServiceImpl implements UserService &#123; private UserDao userDao; //有参构造 public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao; &#125; //无参构造 public UserServiceImpl() &#123; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; 1234&lt;bean id=\"userDao\" class=\"top.rainbowcat.dao.Impl.UserDaoImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"userService\" class=\"top.rainbowcat.service.Impl.UserServiceImpl\"&gt; &lt;constructor-arg name=\"userDao\" ref=\"userDao\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; Bean的依赖注入的数据类型上面的操作，都是注入的引用Bean,除了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。注入数据的三种数据类型： 普通数据类型 引用数据类型 集合数据类型 1234567891011&lt;bean id=\"userDao\" class=\"top.rainbowcat.dao.Impl.UserDaoImpl\"&gt; &lt;!--注入普通数据类型--&gt; &lt;property name=\"username\" value=\"lisi\" /&gt; &lt;!--注入集合数据类型--&gt; &lt;bean id=\"user1\" class=\"top.rainbowcat.domain.User\"&gt; &lt;property name=\"userMap\"&gt; &lt;map&gt; &lt;entry key=\"u1\" value-ref=\"user1\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 引入其他配置文件（分模块开发）实际开发中，Spring的配置内容非常多,这就导致Spring配置很繁杂且体积很大,所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载 小结：Spring的重要配置 &lt;bean&gt;标签 id属性:在容器中Bean实例的唯一标识， 不允许重复 class属性:要实例化的Bean的全限定名 scope属性:Bean的作用范围，常用是Singleton (默认)和prototype &lt;property&gt;标签:属性注入 name属性:属性名称 value属性:注入的普通属性值 ref属性:注入的对象引用值 &lt;list&gt;标签 &lt;map&gt;标签 &lt;properties&gt;标签 &lt;constructor-arg&gt;标签 &lt;import&gt;标签:导入其他的Spring的分文件 Spring的相关APIApplicationContext的实现类 ClassPathXmlApplicationContext它是从类的根路径下加载配置文件推荐使用这种。 FileSystemXmlApplicationContext它是从磁盘路径.上加载配置文件，配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext当使用注解配置容器对象时，需要使用此类来创建spring容器。它用来读取注解。 getBean()方法使用1234public object getBean (String name) throws BeansException &#123; assertBeanFactoryActive() ; &lt;!--例如：getBean(\"UserService\")--&gt; return getBeanFactory() .getBean(name) ; 此类方法时通过id获取，允许容器中有多个相同类型的对象。当容器中某一类型的对象只有一个时，才可以使用下面的方式。 12345public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException &#123; assertBeanFactoryLstive() ; &lt;!--例如：getBean(UserService.class)--&gt; return getBeanFactory().getBean(requiredType) ;&#125; Spring配置数据源（连接池）数据源（连接池）的作用 数据源(连接池)是提高程序性能如出现的 事先实例化数据源，初始化部分连接资源 使用连接资源时从数据源中获取 使用完毕后将连接资源归还给数据源 Spring注解原始注解 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired-起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier,按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法 上标注该方法是Bean的销毁方法 使用注解进行开发时，需要在applicationC ontext.xml中配置组件扫描,作用是指定哪个包及其子包下的Bean 需要进行扫描以便识别使用注解配置的类、字段和方法。 > 示例: 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置组件扫描 --&gt; &lt;context:component-scan base-package=\"top.rainbowcat\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 12345678@Repository(\"userDao\")public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(\"save...\"); &#125;&#125; 123456789101112131415161718@Service(\"userService\") //配置注解@Scope(\"prototype\") //设置作用域public class UserServiceImpl implements UserService &#123; private UserDao userDao; @Autowired //按照类型注入可以省去@Qualifier(\"userDao\") @Qualifier(\"userDao\") //按照id值去匹配,要结合@Autowired使用 //@Resource(name=\"userDao\"),相当于@Autowired + @Qualifier(\"userDao\") //在使用注解进行注入时,set方法可以省去 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; 用注解注入普通数据,可以从容器中获取键值对的数据进行注入: 123456@Value(\"$&#123;jdbc.driver&#125;\")private String driver;public void save()&#123; System.out.println(driver);&#125; 新注解使用上面的注解还不能全部替代xml配置文件,还需要使用注解替代的配置如下: 非自定义的Bean的配置: &lt;bean&gt; 加载properties文件的配置: &lt;context:property-placeholder&gt; 组件扫描的配置: &lt;context:component-scan&gt; 引入其他文件: &lt;import&gt; 注解 说明 @Configuration 用于指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定Spring在初始化容器时要扫描的包。 作用和在Spring的xml配置文件中的 -样 @Bean 使用在方法上，标注将该方法的返回值存储到Spring容器中 @PropertySource 用于加载.properties文件中的配置 @Import 用于导入其他配置类 **示例:** 12345678@Repository(\"userDao\")public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(\"save...\"); &#125;&#125; 1234567891011121314@Service(\"userService\") //service的注解public class UserServiceImpl implements UserService &#123; private UserDao userDao; @Autowired @Qualifier(\"userDao\") public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; 123456789/** * Spring核心配置类 */@Configuration//&lt;!-- 配置组件扫描 --&gt;//&lt;context:component-scan base-package=\"top.rainbowcat\"&gt;&lt;/context:component-scan&gt;@ComponentScan(\"top.rainbowcat\") //配置组件扫描public class SpringConfiguration &#123;&#125; 123456789101112131415161718192021222324//从配置文件加载//&lt;context:property-placeholder location=\"classpath:jdbc.properties\"&gt;&lt;/context:property-placeholder&gt;@PropertySource(\"classpath:jdbc.properties\")public class DataSoueceConfiguration &#123; @Value(\"$&#123;jdbc.drive&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean(\"dataSource\") //对方法添加注解 public DataSource getDataSource() throws Exception &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; Spring集成Junit让SpringJunit负责创建Spring容器,但是需要将配置文件的名称告诉它。将需要进行测试Bean直接在测试类中进行注入。 Spring集成Junit的步骤 导入spring集成Junit的坐标 使用@Runwi th注解替换原来的运行期 使用@ContextConfiguration指定配置文件或配置类 使用@Autowi red注入需要测试的对象 创建测试方法进行测试 pom.xml导入Junit坐标: 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 将测试类中的代码进行修改: 12345678910111213141516171819//指定测试内核@RunWith(SpringJUnit4ClassRunner.class)//指定配置文件@ContextConfiguration(classes = &#123;SpringConfiguration.class, DataSourceConfiguration.class&#125;)public class SpringTest &#123; //需要测试哪个,直接注入即可 @Autowired private UserService userService; @Autowired private DataSource dataSource; @Test public void test() throws SQLException &#123; userService.save(); System.out.println(dataSource.getConnection()); &#125;&#125; Spring的AOP什么是AOPAOP为Aspect Oriented Programming的缩写,意思为面向切面编程,是通过预编译方式和运行期动态代理实现程序功能的统-维护的一种技术。AOP是OOP（面向对象编程）的延续,是软件开发中的一个热点,也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离,从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP的作用及其优势 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强。 优势：减少代码复用，提高开发效率，并且便于维护。 AOP的底层实现实际上，AOP的底层是通过Spring提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 动态代理 动态代理有什么作用及应用场景? 日志集中打印 事务 权限管理 AOP 2.在Spring Aop当中可以哪些方式实现，及区别? - java Proxy(动态构建字节码)(动态构建全新字节码bean初始化的时候) - cglib(动态构建字节码)(动态构建全新字节码bean初始化的时候) - Aspectj(修改目标类的字节，织入代理的字节，在程序编译(编译的时候插入动态代理的字节码，不会生成全新的Class) - instrumentation (修改目标类的字节码、类装载的时候动态拦截去修改,基于javaagent)javaagent:spring-instrument-4.3.8.RELEASE.jar(类装载的时候插入动态代理的字节码，不会生成全新的Class) 以上几种都是对JVM字节码进行操作，但操作方式又有不同。前两种是新增一个完整的Class字节码（必须要用到反射），而后两种是修改现有类的字节码（不需要使用反射）。 静态代理的实现： 123456789101112131415161718192021222324/***目标对象*/public class Rainbow()&#123; public void sayHello()&#123; System.out.println(\"hello\"); &#125;&#125;/***没有接口，使用cglib的方式（代理对象）*/public class RainbowProxy extends Rainbow()&#123; Rainbow target; public void sayHello()&#123; //插入代理的前置逻辑 long begin = System.currentTimeMillis(); //需要增强的目标对象的方法 target.sayHello(); //插入代理的后置逻辑 long end = System.currentTimeMillis(); System.out.println(end-begin); &#125;&#125; 基于jdk的动态代理的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 目标接口 */public interface TargetInterface &#123; public void save();&#125;/** * 接口的实现类 * 目标对象(也即是需要被增强的) */public class Target implements TargetInterface &#123; @Override public void save() &#123; System.out.println(\"save running...\"); &#125;&#125;/** * 增强方法 */public class Advice &#123; public void before()&#123; System.out.println(\"前置增强逻辑\"); &#125; public void after()&#123; System.out.println(\"后置增强逻辑\"); &#125;&#125;/** * 动态代理 */public class ProxyTest &#123; @Test public void Test()&#123; final Target target = new Target();//目标对象 final Advice advice = new Advice();//获得增强方法的对象 //接收动态生成的代理对象，要用接口对象接收（目标对象与代理对象属于同级，故需要用其共同接口接收） TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(), //目标对象的类加载器 target.getClass().getInterfaces(), //目标对象相同的接口字节码对象数组 new InvocationHandler() &#123; //调用代理对象的任何方法，实质上执行的都是invoke方法 //TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(ProxyTest.class.getClassLoader(), new Class[]&#123;TargetInterface.class&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; advice.before();//前置增强 try &#123; return method.invoke(target, args);//target：目标方法，args：实际参数 &#125; finally &#123; advice.after();//后置增强 &#125; &#125; &#125;); //调用代理对象的方法 proxy.save(); &#125;&#125; 基于cglib的动态代理的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 目标对象 */public class Target &#123; public void save() &#123; System.out.println(\"save running...\"); &#125;&#125;/** * 增强方法 */public class Advice &#123; public void before()&#123; System.out.println(\"前置增强逻辑\"); &#125; public void after()&#123; System.out.println(\"后置增强逻辑\"); &#125;&#125;/** * 动态代理 */public class ProxyTest &#123; @Test public void Test()&#123; final Target target = new Target();//目标对象 final Advice advice = new Advice();//获得增强方法的对象 //返回值 就是动态生成的代理对象 基于cglib //1、创建增强器 Enhancer enhancer = new Enhancer(); //2、创建父类（目标类） enhancer.setSuperclass(Target.class); //3、设置回调函数 enhancer.setCallback(new MethodInterceptor()&#123; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; advice.before();//前置增强 Object invoke = method.invoke(target, args); advice.after();//后置增强 return invoke; &#125; &#125;); //4、生成代理对象 Target proxy = (Target) enhancer.create(); //测试 proxy.save(); &#125;&#125; 常用的AOP动态代理技术 JDK代理:基于接口的动态代理技术。目标对象（需要增强的对象）和动态代理（运行时内存中生产的）实现同一个接口。 cglib代理:基于父类的动态代理技术 AOP相关概念 Target（目标对象）：代理的目标的对象 Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类 JoinPoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法, 因为spring只支持方法类型的连接点 Pointcut（切入点）：所谓切入点是指我们要对哪些JoinPoint进行拦截的定义（连接点中要被增强的部分） Advice（通知/增强）：所谓通知是指拦截到JoinPoint之后所要做的事情就是通知 Aspect（切面）：是切点和通知（引介）的结合 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入,而Aspect采用编译期织入和类装载期织入（就是将切点跟通知/增强结合的过程） AOP开发明确的事项 需要编写的内容 编写核心业务代码（目标类的目标方法） 编写切面类，切面类中有通知（增强功能方法） 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合 AOP技术实现的内容 Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 AOP底层使用哪种代理方式 在spring中,框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 AOP配置方式xml方式进行配置 导入AOP相关坐标 创建目标接口和目标类(内部有切点) 创建切面类(内部有增强方法) 将目标类和切面类的对象创建权交给spring 在applicationContextxml中配置织入关系 测试代码 导入坐标（第三方的框架）12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt;&lt;/dependency&gt; 切点表达式 访问修饰符可以省略 返回值类型、包名、类名、方法名乐意用星号*代表任意 包名与类名之间一个点.代表当前包下的类，两个点.. 表示当前包及其子包下的类 参数列表可以使用两个点..表示任意个数，任意类型的参数列表（方法的参数） execution([修饰符]返回值类型包名.类名.方法名(参数)) 例如： 12345678910&lt;!--top.rainbowcat.aop包下的Target类中的save()无参、无返回值方法--&gt;execution(public void top.rainbowcat.aop.Target.save())&lt;!--top.rainbowcat.aop包下的Target类中的任意无返回值的方法--&gt;execution(void top.rainbowcat.aop.Target.*(..))&lt;!--top.rainbowcat.aop包下的任意类中的任意方法，返回值也不限--&gt;execution(* top.rainbowcat.aop.*.*(..))&lt;!--top.rainbowcat.aop包及其子包下的任意类中的任意方法，返回值也不限--&gt;execution(* top.rainbowcat.aop..*.*(..))&lt;!--任意包中任意类的任意方法--&gt;execution(* *..*.*(..)) 通知类型通知的配置语法： &lt;aop:通知类型 method=”切面类中方法名” pointcut=”切面表达式”&gt;&lt;/aop:通知类型&gt; 名称 标签 说明 前置通知 aop:before 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 aop:after-returning 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 aop:around 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都 异常抛出通知 aop:throwing 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 aop:after 用于配置最终通知。无论增强方式执行是否有异常都会执行 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 目标接口 */public interface TargetInterface &#123; public void save();&#125;/** * 接口的实现类 * 目标对象(也即是需要被增强的) */public class Target implements TargetInterface &#123; @Override public void save() &#123; int i = 1/0;//用于测试异常抛出 System.out.println(\"save running...\"); &#125;&#125;/** * 切面类 */public class MyAspect &#123; /** * 前置增强 */ public void before()&#123; System.out.println(\"前置增强...\"); &#125; /** * 后置增强 */ public void afterReturning()&#123; System.out.println(\"后置增强...\"); &#125; /** * 环绕增强方法 * @param pjp 正在执行的连接点（切点） * @return */ public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(\"环绕前增强...\"); //切点方法 Object proceed = pjp.proceed(); System.out.println(\"环绕后增强...\"); return proceed; &#125; /** * 异常抛出增强 */ public void afterThrowing()&#123; System.out.println(\"异常抛出增强...\"); &#125; /** * 最终增强 */ public void after()&#123; System.out.println(\"最终增强...\"); &#125;&#125;/***测试类*/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class AopTest &#123; @Autowired private TargetInterface target; @Test public void Test()&#123; target.save(); &#125;&#125; XML配置： 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--配置目标对象--&gt; &lt;bean id=\"target\" class=\"top.rainbowcat.aop.Target\"&gt;&lt;/bean&gt; &lt;!--配置切面对象--&gt; &lt;bean id=\"myAspect\" class=\"top.rainbowcat.aop.MyAspect\"&gt;&lt;/bean&gt; &lt;!--配置织入、告诉spring需要增强的方法和增强功能，首先要引入AOP命名空间--&gt; &lt;aop:config&gt; &lt;!--声明切面：切点 + 通知--&gt; &lt;aop:aspect ref=\"myAspect\"&gt;&lt;!--只有在此配置了，切面才能被spring容器获取到--&gt; &lt;!--aop:后面的参数是通知，method当中的是切面类中方法的名字--&gt; &lt;aop:before method=\"before\" pointcut=\"execution(public void top.rainbowcat.aop.Target.save())\" /&gt; &lt;aop:after-returning method=\"afterReturning\" pointcut=\"execution(* top.rainbowcat.aop.*.*(..))\" /&gt; &lt;aop:around method=\"around\" pointcut=\"execution(* top.rainbowcat.aop.*.*(..))\" /&gt; &lt;aop:after-throwing method=\"afterThrowing\" pointcut=\"execution(* top.rainbowcat.aop.*.*(..))\" /&gt; &lt;aop:after method=\"after\" pointcut=\"execution(* top.rainbowcat.aop.*.*(..))\" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 切点表达式的抽取当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用pointcut-ref属性代替pointcut属性来引用抽取后的切点表达式。12345678910&lt;aop:config&gt; &lt;!--抽取切点表达式--&gt; &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* top.rainbowcat.aop.*.*(..))\"/&gt; &lt;!--声明切面：切点 + 通知--&gt; &lt;aop:aspect ref=\"myAspect\"&gt;&lt;!--只有在此配置了，切面才能被spring容器获取到--&gt; &lt;!--aop:后面的参数是通知，method当中的是切面类中方法的名字--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"myPointcut\" /&gt; &lt;aop:after method=\"after\" pointcut-ref=\"myPointcut\" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 基于注解的AOP开发 开发步骤 创建目标接口和目标类(内部有切点) 创建切面类(内部有增强方法) 将目标类和切面类的对象创建权交给spring 在切面类中使用注解配置织入关系 在配置文件中开启组件扫描和AOP的自动代理 测试 12345678910111213141516171819202122232425262728293031323334353637/** * 目标对象 */@Component(\"target\") //添加目标类注解public class Target implements TargetInterface &#123; @Override public void save() &#123; System.out.println(\"save running...\"); &#125;&#125;/** * 切面类 */@Component(\"myAspect\") //添加切面类注解@Aspect //标注myAspect是切面public class MyAspect &#123; @Before(\"execution(* top.rainbowcat.aop.*.*(..))\")//通知类型及切点表达式 public void before()&#123; System.out.println(\"前置增强...\"); &#125;&#125;/***测试类*/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")//在配置文件中要设置：组件扫描、AOP自动代理public class AopTest &#123; @Autowired private TargetInterface target; @Test public void Test()&#123; target.save(); &#125;&#125; 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--配置组件扫描--&gt; &lt;context:component-scan base-package=\"top.rainbowcat\" /&gt; &lt;!--配置AOP自动代理--&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; 注解通知的类型通知的配置语法： @通知注解(“切点表达式”) 名称 标签 说明 前置通知 @Before 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 AfterReturning 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 @Around 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都 异常抛出通知 @AfterThrowing 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 @After 用于配置最终通知。无论增强方式执行是否有异常都会执行 切点表达式抽取同xml配置aop一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法,在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下:12345678910111213141516171819202122/** * 切面类 */@Component(\"myAspect\") //添加切面类注解@Aspect //标注myAspect是切面public class MyAspect &#123; /** * 定义切点表达式 */ @Pointcut(\"execution(* top.rainbowcat.aop.*.*(..))\") public void pointcut()&#123;&#125; @Before(\"pointcut()\")//引用方式一 public void before()&#123; System.out.println(\"前置增强...\"); &#125; @AfterReturning(\"MyAspect.pointcut()\")//引用方式二 public void afterReturning()&#123; System.out.println(\"后置增强...\"); &#125;&#125; Spring JdbcTemplate基本使用JdbcTemplate概述它是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。例如:操作关系型数据的JdbcTemplate和ibernateTemplate,操作nosq|数据库的RedisTemplate,操作消息队列的Jms Template等等。 JdbcTemplate开发步骤 导入spring-jdbc和spring-tx坐标 创建数据库表和实体 创建JdbcTemplate对象 执行数据库操作 首先要导入相应坐标： 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 测试类： 12345678910111213141516171819202122232425262728293031323334353637/** * xml配置方式，测试JdbcTemplate */public class JdbcTemplateTest &#123; /** * 不使用容器,直接创建 */ @Test public void Test1()&#123; //创建数据源对象 DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql:///rainbowcat?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF8&amp;serverTimezone=GMT&amp;allowPublicKeyRetrieval=true\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"dong123\"); JdbcTemplate template = new JdbcTemplate(); //在使用前须设置数据源 template.setDataSource(dataSource); String sql = \"select * from userinfo\"; List&lt;UserInfo&gt; infos = template.query(sql, new BeanPropertyRowMapper&lt;UserInfo&gt;(UserInfo.class)); System.out.println(infos); &#125; /** *使用spring容器 */ @Test public void Test2()&#123; ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); JdbcTemplate template = app.getBean(JdbcTemplate.class); String sql = \"select * from userinfo\"; List&lt;UserInfo&gt; infos = template.query(sql, new BeanPropertyRowMapper&lt;UserInfo&gt;(UserInfo.class)); System.out.println(infos); &#125;&#125; 配置文件： 12345678910111213&lt;!--加载外部配置文件--&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt;&lt;!--配置数据源对象--&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.drive&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt;&lt;/bean&gt;&lt;!--jdbc模板对象--&gt;&lt;bean id=\"template\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt; 使用注解进行测试，以及CRUD使用： 123456789101112131415161718192021222324252627282930313233343536373839@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class JdbcDRUDTest &#123; @Autowired private JdbcTemplate template; @Test public void testInsert()&#123; template.update(\"insert into userinfo value (?, ?, ?, ?, ?, ?, ?)\", \"admin\", \"123\", \"管理员\", \"男\", \"admin\", \"12345678900\", \"admin@qq.com\"); &#125; @Test public void testUpdate()&#123; template.update(\"update userinfo set email = ? where username = ?\", \"1029322685@qq.com\", \"admin\"); &#125; @Test public void testDelete()&#123; template.update(\"delete from userinfo where username = ?\", \"admin\"); &#125; @Test public void testQueryAll()&#123; List&lt;UserInfo&gt; infos = template.query(\"select * from userinfo\", new BeanPropertyRowMapper&lt;UserInfo&gt;(UserInfo.class)); System.out.println(infos); &#125; @Test public void testQueryOne()&#123; UserInfo userInfo = template.queryForObject(\"select * from userinfo where username = ?\", new BeanPropertyRowMapper&lt;UserInfo&gt;(UserInfo.class), \"root\"); System.out.println(userInfo); &#125; @Test public void testQueryCount()&#123; Integer count = template.queryForObject(\"select count(*) from userinfo\", Integer.class); System.out.println(count); &#125;&#125; Spring的事务控制编程式事务控制 PlatformTransactionManagerPlatformTransactionManager接口是spring的事务管理器，它里面提供了我们常用的操作事务的方法。 方法 说明 TransactionStatus getTransaction (TransactionDefinition definition) 获取事务的状态信息 void commit (TransactionStatus status) 提交事务 void rollback (TransactionStatus status) 回滚事务 注意：PlatformTransactionManager是接口类型，不同的Dao层技术则有不同的实现类例如: Dao 层技术是jdbc或mybatis时: org.springframework.jdbc.datasource.DataSourceTransactionManager。 Dao层技术是hibernate时: org.springframework.orm.hibernate5.HibernateTransactionManager。 TransactionDefinitionTransactionDefinition是事务的定义信息对象，里面有如下方法: 方法 说明 int getIsolationLevel () 获得事务的隔离级别（设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。） ISOLATION_DEFAULT：默认的 ISOLATION_READ_ UNCOMMITTED：哪种都不能解决 ISOLATION_READ_COMMITTED：解决脏读 ISOLATION_REPEATABLE_READ：解决不可重复读 ISOLATION_SERIALIZABLE：全都能解决（性能较低） int getPropagationBehavior () 获得事务的传播行为（解决业务方法调用业务方法时，事务同一性问题） int getTimeout () 获得超时时间 REQUIRED:如果当前没有事务，就新建-个事务，如果已经存在一个事务中，加入到这个事务中。-般的选择(默认值)。 SUPPORTS:支持当前事务,如果当前没有事务,就以非事务方式执行(没有事务)。 MANDATORY:使用当前的事务，如果当前没有事务，就抛出异常。 REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED:以非事务方式执行操作,如果当前存在事务，就把当前事务挂起。 NEVER:以非事务方式运行，如果当前存在事务，抛出异常。 NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务,则执行REQUIRED类似的操作。 超时时间：默认值是-1,没有超时限制。如果有，以秒为单位进行设置。 是否只读：建议查询时设置为只读。 boolean isReadonly () 是否只读 TransactionStatusTransactionStatus接口提供的是事务具体的运行状态，方法介绍如下。 方法 说明 boolean hasSavepoint() 是否存储回滚点 boolean isCompleted() 事务是否完成 boolean isNewTransaction () 是否是新事务 boolean isRollbackOnly () 事务是否回滚 声明式事务控制Spring的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明,用在Spring配置文件中声明式的处理事务来代替代码式的处理事务。声明式事务处理的作用： 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务,而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可。 在不需要事务管理的时候,只要在设定文件上修改一下,即可移去事务管理服务,无需改变代码重新编译，这样维护起来极其方便 注意: Spring声明式事务控制底层就是AOP。 基于XML的声明式事务控制需要明确以下几点： 谁是切点 谁是通知 配置切面 声明式事务控制的配置要点： 平台事务管理器配置 事务通知的配置 事务aop织入的配置 切点方法的事务参数配置： 12345&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 其中，&lt;tx:method&gt;代表切点方法的事务参数的配置,例如:&lt;tx:method name=”transfer” isolation=”DEFAULT” propagation=”REQUIRED” timeout=”-1” read-only=”false”/&gt; name：切点方法名 isolation：事务的隔离级别 propagation：事务的传播行为 timeout：超时时间 read-only：是否只读 示例（转账，基于XML实现）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Dao层 */public class AccountDaoImpl implements AccountDao &#123; private JdbcTemplate template; public void setTemplate(JdbcTemplate template) &#123; this.template = template; &#125; @Override public void out(String outMan, Double money) &#123; template.update(\"update account set money = money-? where name = ?\", money, outMan); &#125; @Override public void in(String inMan, Double money) &#123; template.update(\"update account set money = money+? where name = ?\", money, inMan); &#125;&#125;/***目标对象，包含切点*/public class AccountServiceImp implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void transfer(String outMan, String inMan, Double money) &#123; accountDao.out(outMan, money); int i = 1/0; //用于测试事务是否起作用 accountDao.in(inMan, money); &#125;&#125;/***模拟前端逻辑*/public class AccountController &#123; public static void main(String[] args) &#123; ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); AccountService accountService = app.getBean(AccountService.class); accountService.transfer(\"admin\", \"tom\", 200.00); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--加载外部配置文件--&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt; &lt;!--配置数据源对象--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.drive&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/bean&gt; &lt;!--jdbc模板对象--&gt; &lt;bean id=\"template\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt;&lt;!--下面是事务相关配置--&gt; &lt;bean id=\"accountDao\" class=\"top.rainbowcat.dao.Impl.AccountDaoImpl\"&gt; &lt;property name=\"template\" ref=\"template\" /&gt; &lt;/bean&gt; &lt;!--目标对象 内部的方法即是切点--&gt; &lt;bean id=\"accountService\" class=\"top.rainbowcat.service.Impl.AccountServiceImp\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置平台事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!--事务是通过connection起作用，connection是从datasource获取的--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!--通知 事务的增强--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!--设置事务属性的参数信息--&gt; &lt;tx:attributes&gt; &lt;!--name：需要被增强的切点，这里可以配置多个事务并且可分别设置参数--&gt; &lt;tx:method name=\"*\"/&gt; &lt;tx:method name=\"transfer\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" timeout=\"-1\" read-only=\"false\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置事务的AOP织入--&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* top.rainbowcat.service.Impl.*.*(..))\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt; 基于注解的声明式事务控制除了对相应的bean添加注解，还需要在要执行事务的方法当中进行配置： 12345678910111213141516@Service(\"accountService\")public class AccountServiceImp implements AccountService &#123; @Autowired private AccountDao accountDao; // 此处的配置相当于 &lt;tx:method name=\"transfer\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" timeout=\"-1\" read-only=\"false\"/&gt; // 也可配置到类名的上方，相当于 &lt;tx:method name=\"*\"/&gt; // 还需要在xml当中配置注解驱动 @Override @Transactional(readOnly = false) public void transfer(String outMan, String inMan, Double money) &#123; accountDao.out(outMan, money); int i = 1/0; //用于测试事务是否起作用 accountDao.in(inMan, money); &#125;&#125; XML配置文件当中，必须要添加注解驱动才能完成事务的控制！！！ 1234567891011121314151617181920212223242526&lt;!--配置组件扫描--&gt;&lt;context:component-scan base-package=\"top.rainbowcat\" /&gt;&lt;!--加载外部配置文件--&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt;&lt;!--配置数据源对象--&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.drive&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt;&lt;/bean&gt;&lt;!--jdbc模板对象--&gt;&lt;bean id=\"template\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt;&lt;!--下面是事务相关配置--&gt;&lt;!--配置平台事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!--事务是通过connection起作用，connection是从datasource获取的--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt;&lt;!--事务的注解驱动--&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt; 注解配置声明式事务控制解析 使用@Transactional在需要进行事务控制的类或是方法上修饰,注解可用的属性同xml配置方式，例如隔离级别、传播行为等。 注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。 使用在方法上,不同的方法可以采用不同的事务参数配置。 Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt;","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Maven使用tomcat8插件","date":"2020-07-24T09:02:37.000Z","path":"2020/07/24/Maven使用tomcat8插件/","text":"在pom.xml当中需要做以下配置： 配置tomcat8-maven-plugin 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat8-maven-plugin&lt;/artifactId&gt; &lt;version&gt;3.0-r1655215&lt;/version&gt; &lt;configuration&gt; &lt;!-- 通过maven tomcat8:run运行项目时，访问项目的端口号 --&gt; &lt;port&gt;80&lt;/port&gt; &lt;!-- 项目访问路径 本例：localhost:9090, 如果配置的aa， 则访问路径为localhost:9090/aa--&gt; &lt;path&gt;/travel&lt;/path&gt; &lt;/configuration&gt;&lt;/plugin&gt; 2.配置tomcat8.x的仓库 1234567891011121314151617181920&lt;!--配置Tomcat8仓库--&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;alfresco-public&lt;/id&gt; &lt;url&gt;https://artifacts.alfresco.com/nexus/content/groups/public&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;alfresco-public-snapshots&lt;/id&gt; &lt;url&gt;https://artifacts.alfresco.com/nexus/content/groups/public-snapshots&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;!--这个google的用不了--&gt; &lt;!--&lt;pluginRepository&gt; &lt;id&gt;beardedgeeks-releases&lt;/id&gt; &lt;url&gt;http://beardedgeeks.googlecode.com/svn/repository/releases&lt;/url&gt; &lt;/pluginRepository&gt;--&gt; &lt;/pluginRepositories&gt;","tags":[]},{"title":"如何使用maven进行开发","date":"2020-07-16T09:14:20.000Z","path":"2020/07/16/如何使用maven进行开发/","text":"什么是maven Maven简介Maven是项目进行模型抽象，充分运用面向对象思想，通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven除了以程序构建能力为特色之外，还提供高级项目管理工具。下载地址：http://archive.apache.org/dist/maven/maven-3/ Maven的主要作用 对第三方jar包的统一管理。意思其实就是通过本地仓库或者是远程仓库更或者是中央仓库进行依赖管理，省去了导入jar包的操作。不过一般我们在配置Maven时会选择阿里的远程仓库，不会去连接中央仓库，因为太慢了，而且阿里不仅拥有中央仓库的所有jar包而且开源了自身许多有用的jar包，如数据库连接池jar包Druid(德鲁伊)。 将项目分模块构建，提高开发效率。意思就是说使用Maven时，其构建项目时，会将包分好，方便工作人员协同开发，提高效率。 Maven提供一套对项目生命周期管理的标准。意思是说，Maven为项目提供了许多有关jar包的作用域，作用范围，类的生命周期，运行范围。以及项目的编译，部署等都提供了很好的接口，只要配置下就好了。减少了开发人员思考这些无关紧要的东西，只要遵循Maven的标准就可以了。 maven项目标准目录结构maven项目标准目录结构src/main/java目录 核心代码部分。src/main/resources 配置文件部分。src/test/java目录测试代码部分。src/test/resources测试配置文件。src/main/webapp页面资源，js, CSs,图片等等 maven项目常用命令在项目的目录下：mvn clean：清除项目编译文件mvn compile：将src/main下的文件进行编译mvn test：将src/main、src/test下的文件进行编译mvn package：对项目进行打包mvn install：执行除了clean以外的操作，同时还将项目安装到本地仓库mvn deploy：发布项目 maven生命周期 清除编译信息 编译 测试 打包 安装 发布 clean compile test package install 清理生命周期 默认生命周期 站点生命周期 #### IDEA集成maven插件 IDEA主界面当中，点击configure-settings 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt; javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version &lt;scope&gt;provided&lt;&#x2F;scope&gt; &#x2F;&#x2F;解决jar包冲突，只在编译的时候起作用，项目运行时不起作用（test：只在测试时有用） &lt;&#x2F;dependency&gt;&lt;dependencies&gt; ## 配置自己的maven骨架 阿里云镜像： 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt; &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;&lt;&#x2F;mirror&gt;","tags":[]},{"title":"Redis简单使用","date":"2020-07-16T08:52:11.000Z","path":"2020/07/16/Redis简单使用/","text":"Redis简单了解概念Redis是一款高性能的NOSQL系列的非关系型数据库。 1.1.什么是NOSQLNoSQL(NoSQL = Not only SQL), 意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关 系型数据库比较优点:1)成本: nosq1数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。2)查询速度: nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosq1数据库。3)存储数据的格式: nosql的存储格式是key ,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。4)扩展性:关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。缺点:1)维护的工具和资料有限，因为nosq1是属于新的技术，不能和关系型数据库10几年的技术同日而语。2)不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户 的学习和使用成本。3)不提供关系型数据库对事务的处理。1.1.2.非关系型数据 库的优势:1)性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。2)可扩展性同样也是因为基于键值对，数据之间没有耦合性,所以非常容易水平扩展。1.1.3.关系型数据库的优势:1)复杂查询可以用sQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。2) 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势,反之亦然。1.1.4.总结关系型数据库与NoSQL数据库并非对立而是互补的关系,即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库,让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据。 1.2.主流的NOSQL产品键值(Key-Value )存储数据库 相关产品: Tokyo Cabinet/Tyrant、 Redis、 Voldemort、 Berkeley DB 典型应用:内容缓存，主要用于处理大量数据的高访问负载。 数据模型:一系列键值对 优势:快速查询 劣势:存储的数据缺少结构化列存储数据库 相关产品: Cassandra, HBase, Riak 典型应用:分布式的文件系统 数据模型:以列簇式存储,将同- -列数据存在一-起 优势:查找速度快,可扩展性强，更容易进行分布式扩展 劣势:功能相对局限文档型数据库 相关产品: CouchDB、MongoDB 典型应用: Web应用(与Key-Value类似， Value是结构化的) 数据模型: - 系列键值对 优势:数据结构要求不严格 劣势:查询性能不高， 而且缺乏统一的查询语法图形(Graph)数据库 相关数据库: Neo4J、InfoGrid、 Infinite Graph 典型应用:社交网络 数据模型:图结构 优势:利用图结构相关算法。 劣势:需要对整个图做计算才能得出结果，不容易做分布式的集群方案。1.3什么是RedisRedis是用C语言开发的一个开源的高性能键值对(key-value) 数据库，官方提供测试数据, 50个并发执行100000个请求,读的速度是110000次/s ,写的速度是81000次/s，且Redis通过 提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下: 1)字符串类型string 2)哈希类型hash 3)列表类型list 4)集合类型set 5)有序集合类型sortedset1.3.1 redis的应用场景 缓存(数据查询、短连接、新闻内容、商品内容等等) 聊天室的在线好友列表 任务队列。(秒杀、 抢购、12306等等) 应用排行榜 网站访问统计 数据过期处理(可以精确到毫秒 分布式集群架构中的session分离 下载安装官网：https://www.redis.io/中文网站：https://www.redis.net.cn/windows下载地址（微软的GitHub地址）：https://github.com/MSOpenTech/redis/releases 下载完直接解压即可，无需安装。 - redis.windows.conf :配置文件 - redis-cli.exe : redis的客户端 - redis-server.exe : redis服务器端 命令操作redis的数据结构：redis存储的是: key, value格式的数据，其中key都是字符串，value有5种不同的数据结构。 字符串类型string 存储：set key value 获取：get key 删除：del key set username lisiget usernamedel username 哈希类型hash（map格式） 存储：hset key filed value 获取：hget key filed（获取指定filed的值）、hgetall key（获取key的所有值） 删除：hdel key filed hset user username lisihset user password 123hget user usernamehdel user username //删除键（username）和对应的值hgetall user //获取键的所有值 12345127.0.0.1:6379&gt; hgetall user1) &quot;username&quot;2) &quot;lisi&quot;3) &quot;password&quot;4) &quot;123&quot; 列表类型list（linkedlist格式）可以添加一个元素到列表的头部(左边)或者尾部(右边) 存储： lpush key value（将元素添加到列表头部/左侧） rpush key value（将元素添加到列表尾部/右侧） 获取： lrange key start end（范围获取） 删除： lpop key（删除列表头部元素，并将元素返回） rpop key（删除列表尾部元素，并将元素返回） 123456789101112131415161718127.0.0.1:6379&gt; LPUSH mylist aaa bbb ccc(integer) 3127.0.0.1:6379&gt; LRANGE mylist 0 21) &quot;ccc&quot;2) &quot;bbb&quot;3) &quot;aaa&quot;127.0.0.1:6379&gt; lpop mylist&quot;ccc&quot;127.0.0.1:6379&gt; LRANGE mylist 0 21) &quot;bbb&quot;2) &quot;aaa&quot;127.0.0.1:6379&gt; lpush mylist aaa bbb(integer) 4127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;bbb&quot;2) &quot;aaa&quot;3) &quot;bbb&quot;4) &quot;aaa&quot; 集合类型set（不允许重复元素） 存储：sadd key value 获取：smembers key（获取set集合中所有元素） 删除：srem key value（删除set集合中的某个元素） 1234567891011121314151617181920212223127.0.0.1:6379&gt; sadd myset a b c(integer) 3127.0.0.1:6379&gt; smembers myset1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;127.0.0.1:6379&gt; sadd myset a(integer) 0127.0.0.1:6379&gt; sadd myset d e(integer) 2127.0.0.1:6379&gt; smembers myset1) &quot;b&quot;2) &quot;a&quot;3) &quot;d&quot;4) &quot;c&quot;5) &quot;e&quot;127.0.0.1:6379&gt; srem myset a(integer) 1127.0.0.1:6379&gt; smembers myset1) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;4) &quot;e&quot; 有序集合类型sortedset（不允许重复元素，且元素有序） 存储：zadd key score value 获取：zrange key start end 删除：zrem key value 123456789101112131415161718192021222324127.0.0.1:6379&gt; zadd mysort 12 zhang(integer) 1127.0.0.1:6379&gt; zadd mysort 20 li(integer) 1127.0.0.1:6379&gt; zadd mysort 9 zhao(integer) 1127.0.0.1:6379&gt; zrange mysort 0 -11) &quot;zhao&quot;2) &quot;zhang&quot;3) &quot;li&quot;127.0.0.1:6379&gt; zrange mysort 0 -1 withscores1) &quot;zhao&quot;2) &quot;9&quot;3) &quot;zhang&quot;4) &quot;12&quot;5) &quot;li&quot;6) &quot;20&quot;127.0.0.1:6379&gt; zrem mysort zhang(integer) 1127.0.0.1:6379&gt; zrange mysort 0 -1 withscores1) &quot;zhao&quot;2) &quot;9&quot;3) &quot;li&quot;4) &quot;20&quot; 通用命令 kyes * ：查询所有的键 type key ：获取键对应的value类型 del key ：删除指定key的key value 12345678910111213141516171819127.0.0.1:6379&gt; keys *1) &quot;myset&quot;2) &quot;user&quot;3) &quot;mylist&quot;4) &quot;mysort&quot;127.0.0.1:6379&gt; type userhash127.0.0.1:6379&gt; type mysortzset127.0.0.1:6379&gt; type mylistlist127.0.0.1:6379&gt; type mysetset127.0.0.1:6379&gt; del user(integer) 1127.0.0.1:6379&gt; keys *1) &quot;myset&quot;2) &quot;mylist&quot;3) &quot;mysort&quot; 持久化由于Redis是一个内存数据库，当redis服务器重启时数据会丢失，可以将redis内存中的数据持久化保存到硬盘中。Redis持久化机制有两种： RDB：默认方式，不需要进行配置。在一定间隔时间中，检测key的变化情况，然后进行持久化数据。 编辑redis.windows.conf文件 123456after 900 sec (15 min) if at least 1 key changed&lt;br&gt;save 900 1&lt;br&gt;after 300 sec (5 min) if at least 10 keys changed&lt;br&gt;save 300 10&lt;br&gt;after 60 sec if at least 10000 keys changed&lt;br&gt;save 60 10000&lt;br&gt; 重启redis服务器，并指定配置文件名称D: \\redis&gt;redis-server.exe redis.windows.conf AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后持久化数据。编辑redis.windows.conf文件。找到”appendonly no”，改为”appendonly yes”,此时已开启AOF。123# appendfsync always &#x2F;&#x2F;每次操作都进行持久化appendfsync everysec &#x2F;&#x2F;每隔一秒进行一次持久化# appendfsync no &#x2F;&#x2F;不进行持久化 Java客户端Jedis一款java操作redis数据库的工具。需要先导入相关jar包。jedis的jar包下载地址：http://mvnrepository.com/artifact/redis.clients/jedishttp://mvnrepository.com/artifact/org.apache.commons/commons-pool212345678910//简单的使用@Testpublic void test1()&#123; //1.获取连接 Jedis jedis = new Jedis(\"localhost\", 6379); //2. 操作 jedis.set(\"username\", \"zhangsan\"); //3. 关闭连接 jedis.close();&#125; Jedis操作各种Redis中的数据结构 字符串类型stringset、get123456789101112@Testpublic void test2()&#123; //1.获取连接 Jedis jedis = new Jedis(\"localhost\", 6379); //2. 操作 jedis.set(\"username\", \"zhangsan\"); System.out.println(jedis.get(\"username\")); //可以使用setex()方法存储指定过期时间的key value jedis.setex(\"activecode\", 20, \"hello\");//将activecode: hehe键值对存入redis， 并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close();&#125; 哈希类型hash : map格式hset、hget1234567891011121314151617181920212223 @Testpublic void test()&#123; //1.获取连接 Jedis jedis = new Jedis(\"localhost\", 6379); //2. 操作 jedis.hset(\"user\", \"name\", \"lisi\"); jedis.hset(\"user\", \"age\", \"20\"); jedis.hset(\"user\", \"address\", \"beijing\"); //获取 System.out.println(jedis.hget(\"user\", \"name\")); Map&lt;String, String&gt; user = jedis.hgetAll(\"user\"); System.out.println(user); Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet)&#123; String value = user.get(key); System.out.println(key + \":\" + value); &#125; //3. 关闭连接 jedis.close();&#125; 列表类型list : linkedlist格式。 支持重复元素lpush/rpush 、lpop/rpop、lrange start end（范围获取）12345678910111213141516171819202122@Testpublic void test()&#123; //1.获取连接 Jedis jedis = new Jedis(\"localhost\", 6379); //2. 操作 jedis.lpush(\"myList\", \"a\", \"b\", \"c\"); jedis.rpush(\"myList\", \"a\", \"b\", \"c\"); List&lt;String&gt; myList = jedis.lrange(\"myList\", 0, -1); System.out.println(myList); String element1 = jedis.lpop(\"myList\"); System.out.println(element1); System.out.println(jedis.lrange(\"myList\", 0, -1)); String element2 = jedis.rpop(\"myList\"); System.out.println(element2); System.out.println(jedis.lrange(\"myList\", 0, -1)); //3. 关闭连接 jedis.close();&#125; 集合类型set:不允许重复元素sadd123456789101112131415@Testpublic void test()&#123; //1.获取连接 Jedis jedis = new Jedis(\"localhost\", 6379); //2. 操作 jedis.sadd(\"mySet\", \"a\", \"b\", \"c\"); Set&lt;String&gt; mySet = jedis.smembers(\"mySet\"); System.out.println(mySet); jedis.srem(\"mySet\", \"a\"); System.out.println(jedis.smembers(\"mySet\")); //3. 关闭连接 jedis.close();&#125; 有序集合类型sortedset :不允许重复元素，且元素有顺序zadd12345678910111213141516@Testpublic void test()&#123; //1.获取连接 Jedis jedis = new Jedis(\"localhost\", 6379); //2. 操作 jedis.zadd(\"sortSet\", 3, \"小张\"); jedis.zadd(\"sortSet\", 5, \"小李\"); jedis.zadd(\"sortSet\", 10, \"小王\"); Set&lt;String&gt; sortSet = jedis.zrange(\"sortSet\", 0, -1); System.out.println(sortSet); System.out.println(jedis.zrangeWithScores(\"sortSet\", 0, -1)); //3. 关闭连接 jedis.close();&#125; Jedis连接池：JedisPool 创建JedisPool连接池对象 调用getResource()方法获取Jedis连接123456789101112131415161718@Testpublic void test()&#123; //创建配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象，不设置配置参数会使用默认的// JedisPool jedisPool = new JedisPool(); JedisPool jedisPool = new JedisPool(config, \"localhost\", 6379); //2. 获取连接 Jedis jedis = jedisPool.getResource(); //3.操作 //4. 关闭，归还到连接池 jedis.close();&#125; 一些常用的参数配置： 12345678910111213141516171819202122#收大活动对象数redis . pool . maxTotal&#x3D;1000#最大能够保持idel状态的对象数redis. pool . maxIdle&#x3D;100#坡小能够保持idel状态的对象数redis. pool. minIdle&#x3D;50#当池内没有返回对象时，最大等待时间redis. pool . maxWaitMillis&#x3D;10000#当调用borrow Object方法时，是否进行有效性检查redis. pool. testOnBorrow true#当调用return object方法时，是否进行有效性检查redis. pool. testOnReturn&#x3D;true#“空闲链接&quot;检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1.redis. pool. timeBetweenEvi ctionRunsMillis&#x3D;30000#向调用者输出“链接”对象时，是否检测它的空闲超时;redis. pool. testWhileIdle&#x3D;true#对于“空闲链接&quot;检测线程而言，每次检测的链接资源的个数。默认为3.redis . pool . numTestsPerEvictionRun&#x3D;50#redis服务器的IPredis. ip &#x3D;XXXXXX#redis服务器的Portredis1. port&#x3D; &#x3D;6379 连接池工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Jedis工具类 * 加载配置文件 * 提供获取连接的方法 */public class JedisPoolUtils &#123; private static JedisPool jedisPool; static &#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(\"jedis.properties\"); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(\"maxTotal\"))); config.setMaxIdle(Integer.parseInt(pro.getProperty(\"maxIdle\"))); //初始化 jedisPool = new JedisPool(config, pro.getProperty(\"host\"), Integer.parseInt(pro.getProperty(\"port\"))); &#125; /** * 获取连接的方法 * @return */ public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125; /** * 关闭连接的方法 */ public static void close()&#123; jedisPool.close(); &#125;&#125; 案例案例需求: 提供index.html页面，页面中有一个省份下拉列表 当页面加载完成后发送ajax请求,加载所有省份使用ieda调试程序时，刚开始报了个异常：java.lang.NoClassDefFoundError: org/slf4j/LoggerFactoryjar包下载链接https://repo1.maven.org/maven2/org/slf4j/ 1234567891011121314151617181920import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import top.rainbowcat.dao.ProvinceDao;import top.rainbowcat.domain.Province;import top.rainbowcat.util.JDBCUtils;import java.util.List;public class ProvinceDaoImpl implements ProvinceDao &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); @Override public List&lt;Province&gt; findAll() &#123; String sql = \"select * from province\"; List&lt;Province&gt; provinces = template.query(sql, new BeanPropertyRowMapper&lt;Province&gt;(Province.class)); return provinces; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import redis.clients.jedis.Jedis;import top.rainbowcat.dao.ProvinceDao;import top.rainbowcat.dao.impl.ProvinceDaoImpl;import top.rainbowcat.domain.Province;import top.rainbowcat.service.ProvinceService;import top.rainbowcat.util.JedisPoolUtils;import java.util.List;public class ProvinceServiceImpl implements ProvinceService &#123; private ProvinceDao provinceDao = new ProvinceDaoImpl(); @Override public List&lt;Province&gt; findAll() &#123; return provinceDao.findAll(); &#125; /** * 使用Redis缓存 * @return */ @Override public String findAllJson() &#123; //1. 先从redis中查询数据 Jedis jedis = JedisPoolUtils.getJedis(); String province_json = jedis.get(\"province\"); System.out.println(province_json); if (province_json == null || province_json.length() == 0)&#123; //redis中没有数据,从数据库中查询 System.out.println(\"Redis中没有数据，正在进行数据库查询...\"); List&lt;Province&gt; list = provinceDao.findAll(); //将list集合序列化为json ObjectMapper mapper = new ObjectMapper(); try &#123; province_json = mapper.writeValueAsString(list); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; //将json数据存入redis当中 jedis.set(\"province\", province_json); jedis.close(); &#125;else &#123; //在redis中查询到数据 System.out.println(\"Redis中有数据，正在查询缓存...\"); &#125; return province_json; &#125;&#125; 12345678910111213141516171819202122232425import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/findProvince\")public class FindProvinceServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //调用方法查询 ProvinceService service = new ProvinceServiceImpl(); String json = service.findAllJson(); System.out.println(json); response.setContentType(\"application/json;charset=utf-8\"); response.getWriter().write(json); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;select id=\"province\"&gt; &lt;option&gt;--请选择省份--&lt;/option&gt;&lt;/select&gt;&lt;script&gt; $(function () &#123; $.get(\"findProvince\", &#123;&#125;, function (d) &#123; //获取select var province = $(\"#province\"); //遍历json数组 $(d).each(function () &#123; //创建option var option = \"&lt;option name='\"+ this.id +\"'&gt;\"+ this.name + \"&lt;/option&gt;\"; //调用select的append方法进行追加 province.append(option); &#125;); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意:使用redis缓存一些不经常发生变化的数据。 数据库的数据一旦发生改变，则需要更新缓存。 数据库的表执行增删改的相关操作，需要将redis缓存数据情况，再次存入 在service对应的增删改方法中，将redis数据删除。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"AJax & JSON","date":"2020-07-15T03:00:50.000Z","path":"2020/07/15/AJax & JSON/","text":"AJAXAJAX概念：Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。 实现方式原生JS实现方式 $.ajax() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;input type=\"button\" value=\"发送异步请求\" onclick=\"fn()\"&gt;&lt;script&gt; // function fn() &#123; //1.创建核心对象 var xmlHttp; if (window.XMLHttpRequest)&#123; //code for IE7+,Firefox,Chrome,Opera,Safari xmlHttp = new XMLHttpRequest(); &#125;else &#123; //code for IE6,IE5 xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; //2.建立连接 /** * xmlHttp.open(\"GET\", \"test1.txt\", true) * 参数： * 1.请求方式：GET、POST * 2.请求的URL * 3.同步或异步请求：true（异步）、false（同步） */ xmlHttp.open(\"GET\", \"testServlet?name=张三\", true); //3.发送请求 /** * 如果是GET请求：URL参数在open中拼接 * 如果是POST请求：URL在send中定义 */ xmlHttp.send(); //4.接收和处理响应结果(xmlHttp.responseText) /** * 当xmlHttp对象的 响应就绪状态改变时触发事件(onreadystatechange) * onreadystatechange有以下几种状态 * 1. 0：请求未初始化 * 2. 1：服务器连接已建立 * 3. 2：请求已接收 * 4. 3：请求处理中 * 5. 4：请求已完成，且相应已完成 */ xmlHttp.onreadystatechange = function () &#123; if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200)&#123; // 获取服务器的响应结果 var responseText = xmlHttp.responseText; alert(responseText); &#125; &#125; &#125;&lt;/script&gt; 1234request.setCharacterEncoding(\"UTF-8\");String name = request.getParameter(\"name\");System.out.println(name);response.getWriter().write(\"hello\" + name); jQuery实现方式123456789101112&lt;script&gt; function fn() &#123; $.ajax(&#123; url: \"testServlet\", type: \"POST\", data: &#123;\"name\": \"jack\"&#125;, success: function (data) &#123; alert(data); &#125;, &#125;); &#125;&lt;/script&gt; $.get() 和 $.post() 语法：$.get(url, [data], [callback], [type]) 12345&lt;script&gt; function fn() &#123; $.post(\"testServlet\", &#123;\"name\": \"tom\"&#125;, function(d)&#123;alert(d)&#125;, \"text\"); &#125;&lt;/script&gt; JSONJSON概念：JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 JSON语法：基本规则 数据在键/值对中：json数据由键值对构成。 键用引号引起来，也可以不是用引号 值的取值类型： 数字（证书或浮点数） 字符串（在双引号中） 逻辑值（true/false） 数组（在方括号中）{“persons”:[{},{}]} 对象（在花括号中）{“address”:{“province”:”陕西”…}} null 123456789101112131415161718192021&lt;script&gt; //1. 基本格式 var a = &#123;\"name\": \"张三\", \"age\": 20, \"address\": \"北京\"&#125;; console.log(a); //2. 嵌套格式 var b = [ &#123;\"name\": \"张三\", \"age\": 20, \"address\": \"北京\"&#125;, &#123;\"name\": \"李四\", \"age\": 20, \"address\": \"北京\"&#125;, &#123;\"name\": \"王五\", \"age\": 20, \"address\": \"北京\"&#125; ]; console.log(b); var c = &#123; \"person\": [ &#123;\"name\": \"张三\", \"age\": 20, \"address\": \"北京\"&#125;, &#123;\"name\": \"李四\", \"age\": 20, \"address\": \"北京\"&#125;, &#123;\"name\": \"王五\", \"age\": 20, \"address\": \"北京\"&#125; ] &#125; console.log(b);&lt;/script&gt; 数据由都好分隔：多个键值对由逗号分隔。 花括号保存对象：使用{}定义json格式 方括号保存数组：[] 获取数据 json对象.键名 12console.log(a.name);//获取的结果是：张三console.log(a.age);//获取的结果是：20 json对象[“键名”] 12console.log(a[\"name\"])//获取的结果是：张三console.log(a[\"age\"]);//获取的结果是：20 数组对象[索引] 12console.log(c.person[1].name);//获取的结果是：李四console.log(c[\"person\"][0].name);;//获取的结果是：张三 JSON的遍历123456var a = &#123;\"name\": \"张三\", \"age\": 20, \"address\": \"北京\"&#125;; for (var key in a) &#123; console.log(key);//获取所有的键（字符串格式） console.log(key + \":\" + a[key]);//获取所有的键和值（字符串格式） &#125; 123456789101112var b = [ &#123;\"name\": \"张三\", \"age\": 20, \"address\": \"北京\"&#125;, &#123;\"name\": \"李四\", \"age\": 20, \"address\": \"北京\"&#125;, &#123;\"name\": \"王五\", \"age\": 20, \"address\": \"北京\"&#125; ] for (var i = 0; i &lt; b.length; i++) &#123; var c = b[i]; for (var key in c) &#123; console.log(key+ \":\" + c[key]) &#125; &#125; JSON数据和Java对象的转换一般使用json解析器进行。常见的有Jsonlib、Gjson、fastjson、jackson JSON转为Java对象 使用步骤 导入jackson的相关jar包 创建jackson核心对象ObjectMapper 调用ObjectMapper的相关方法进行转换 转换方法readValue(json字符串数据, class类型)： 12345678910@Test public void test5() throws Exception &#123; //1.初始化json字符串 String json = \"&#123;\\\"name\\\":\\\"张三\\\",\\\"age\\\":20,\\\"address\\\":\\\"北京\\\"&#125;\"; //2.转换 ObjectMapper mapper = new ObjectMapper(); Persion persion = mapper.readValue(json, Persion.class); System.out.println(persion); &#125; Java对象转为JSON 使用步骤 导入jackson的相关jar包 创建jackson核心对象ObjectMapper 调用ObjectMapper的相关方法进行转换 转换方法 writeValue(参数1, obj)： 参数1： File 将obj对象转换为json字符串，并保存到指定文件中 Writer 将obj对象转换为json字符串，并将json数据填充到字符输出流 OutputStream obj对象转换为json字符串，并将json数据填充到字节输出流 writeValueAsString()：将对象转换为json字符串 1234567891011121314151617181920212223public class JacksonTest &#123; /** * Java转json */ @Test public void test() throws Exception &#123; //1.创建person对象 Persion person = new Persion(); person.setName(\"张三\"); person.setAge(20); person.setAddress(\"北京\"); //2.创建jackson核心对象 ObjectMapper mapper = new ObjectMapper(); //3.转换 //mapper.writeValue(new File(\"d://a.txt\"), person);//写入到文件 //mapper.writeValue(new FileWriter(\"d://b.txt\"), person);//写入到字符流 String json = mapper.writeValueAsString(person); System.out.println(json); &#125;&#125; 注解(在实体类当中添加) @JsonIgnore：排除属性。 @JsonFormat：属性值的格式化。 1234567public class Persion &#123; private String name; private Integer age; private String address; @JsonIgnore //该注解会将属性忽略（输出时） private Date birthday;&#125; {“name”:”张三”,”age”:20,”address”:”北京”} 1234567public class Persion &#123; private String name; private Integer age; private String address; @JsonFormat(pattern = \"yyyy-MM-dd\") //该注解会对属性进行格式化 private Date birthday;&#125; {“name”:”张三”,”age”:20,”address”:”北京”,”birthday”:”2020-07-15”} 复杂Java对象转换 List（z转换后是数组格式） 1234567891011121314151617181920212223242526272829303132@Testpublic void test3() throws Exception &#123; &#x2F;&#x2F;1.创建person对象 Persion p1 &#x3D; new Persion(); p1.setName(&quot;张三&quot;); p1.setAge(20); p1.setAddress(&quot;北京&quot;); p1.setBirthday(new Date()); Persion p2 &#x3D; new Persion(); p2.setName(&quot;张三&quot;); p2.setAge(20); p2.setAddress(&quot;北京&quot;); p2.setBirthday(new Date()); Persion p3 &#x3D; new Persion(); p3.setName(&quot;张三&quot;); p3.setAge(20); p3.setAddress(&quot;北京&quot;); p3.setBirthday(new Date()); &#x2F;&#x2F;创建List集合 ArrayList&lt;Persion&gt; list &#x3D; new ArrayList&lt;&gt;(); list.add(p1); list.add(p2); list.add(p3); &#x2F;&#x2F;2.转换 ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(list); System.out.println(json);&#125; [{“name”:”张三”,”age”:20,”address”:”北京”,”birthday”:”2020-07-15”},{“name”:”张三”,”age”:20,”address”:”北京”,”birthday”:”2020-07-15”},{“name”:”张三”,”age”:20,”address”:”北京”,”birthday”:”2020-07-15”}] Map(转换后是对象格式) 1234567891011121314@Testpublic void test4() throws Exception &#123; //1.创建person对象 HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"张三\"); map.put(\"age\", \"20\"); map.put(\"address\", \"北京\"); //2.转换 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(map); System.out.println(json);&#125; 案例注册时用户名校验 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户注册&lt;/title&gt; &lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //给username绑定blur事件 $(\"#username\").blur(function () &#123; //获取文本框内容 var username = $(this).val(); var s_username = $(\"#s_username\"); $.get(\"findUserNameServlet\", &#123;username, username&#125;, function (d) &#123; if (d.userExist == true)&#123; //用户名岑在 s_username.html(d.msg); s_username.css(\"color\", \"red\"); &#125;else &#123; //用户名不存在 s_username.html(d.msg); s_username.css(\"color\", \"green\"); &#125; &#125;,\"json\"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type=\"text\" id=\"username\" name=\"username\" placeholder=\"请输入用户名\"&gt; &lt;span id=\"s_username\"&gt;&lt;/span&gt; &lt;br&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\"&gt;&lt;br&gt; &lt;input type=\"button\" value=\"注册\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334@WebServlet(\"/findUserNameServlet\")public class FindUserNameServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); //解决服务器响应数据在客户端中文乱码 response.setContentType(\"text/html;charset=utf-8\"); //设置相应格式为json //response.setContentType(\"application/json;charset=utf-8\"); String username = request.getParameter(\"username\"); //此处应从数据库中查询，战且简化操作 HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); if (\"tom\".equals(username))&#123; //用户名存在 map.put(\"userExist\", true); map.put(\"msg\", \"用户名已存在！\"); &#125;else &#123; //用户名不存在 map.put(\"userExist\", false); map.put(\"msg\", \"用户名可用！\"); &#125; //将map转为json ObjectMapper mapper = new ObjectMapper(); //将数据写入到客户端 mapper.writeValue(response.getWriter(), map); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125;","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JQuery高级使用","date":"2020-07-14T08:13:36.000Z","path":"2020/07/14/JQuery高级使用/","text":"动画三种方式显示和隐藏元素 默认显示和隐藏方式 show([speed,[easing],[fn]]) hide([speed,[easing],[fn]]) toggle([speed,[easing],[fn]]) 12345678910111213141516171819&lt;input type=\"button\" value=\"点击按钮隐藏div\" onclick=\"hideFn()\"&gt;&lt;input type=\"button\" value=\"点击按钮显示div\" onclick=\"showFn()\"&gt;&lt;input type=\"button\" value=\"点击按钮切换div显示或隐藏\" onclick=\"toggleFn()\"&gt;&lt;div id=\"showDiv\" style=\"width: 200px;height: 200px;background-color:pink;\"&gt; div。。。&lt;/div&gt;&lt;script&gt; function hideFn() &#123; $(\"#showDiv\").hide(\"slow\",\"linear\"); &#125; function showFn() &#123; $(\"#showDiv\").show(\"fast\",\"swing\", function () &#123; alert(\"显示了\") &#125;); &#125; function toggleFn() &#123; $(\"#showDiv\").toggle(\"slow\"); &#125;&lt;/script&gt; 滑动显示和隐藏方式 slideDown([speed,[easing],[fn]]) slideUp([speed,[easing],[fn]]) slideToggle([speed,[easing],[fn]]) 123456789function hideFn() &#123; $(\"#showDiv\").slideUp(\"slow\");&#125;function showFn() &#123; $(\"#showDiv\").slideDown(\"fast\");&#125;function toggleFn() &#123; $(\"#showDiv\").slideToggle(\"slow\");&#125; 淡入淡出显示和隐藏方式 fadeIn([speed,[easing],[fn]]) fadeOut([speed,[easing],[fn]]) fadeToggle([speed,[easing],[fn]]) 123456789function hideFn() &#123; $(\"#showDiv\").fadeOut(\"slow\");&#125;function showFn() &#123; $(\"#showDiv\").fadeIn(\"fast\");&#125;function toggleFn() &#123; $(\"#showDiv\").fadeToggle(\"slow\");&#125; 参数介绍 speed：动画的速度。有三个预定义的值（”slow”、”normal”、”fast”），或表示动画时长的毫秒数（如：1000）。 easing：用来指定切换效果，默认是”swing”（先慢，中间快，最后又变慢），可以用参数”linear”（匀速）。 fn：在动画完成时执行的函数，每个元素执行一次。 遍历js的遍历方式（for）1234567891011121314&lt;ul id=\"city\"&gt; &lt;li&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;天津&lt;/li&gt; &lt;li&gt;重庆&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; $(function () &#123; var citys = $(\"#city li\"); for (var i = 0; i &lt; citys.length; i++) &#123; alert(i+\":\"+citys[i].innerHTML); &#125; &#125;);&lt;/script&gt; jQuery的遍历方式 jQuery对象，each(callback)：callback是回调函数 12345var citys = $(\"#city li\");citys.each(function () &#123; //第一种方式，不能获取索引 alert(this.innerHTML)&#125;); 12345var citys = $(\"#city li\");citys.each(function (index, element) &#123; //第二种方式，在回调函数中定义参数：index（索引）、element（元素对象） alert(index + \":\" + element.innerHTML);&#125;); 123456789var citys = $(\"#city li\"); citys.each(function (index, element) &#123; //第三种方式，在回调函数中定义参数：index（索引）、element（元素对象） if (\"上海\"==$(element).html())&#123; //如果返回false，结束循环（break）；返回true，结束本次循环，继续下一次循环（continue） return true; &#125; alert(index + \":\" + $(element).html()); &#125;); $.each(object, [callback]) object参数：可以是jquery对象，也可以是数组对象。 123456789var citys = $(\"#city li\"); $.each(citys, function (index, element) &#123; //第三种方式，在回调函数中定义参数：index（索引）、element（元素对象） if (\"上海\"==$(element).html())&#123; //如果返回false，结束循环（break）；返回true，结束本次循环，继续下一次循环（continue） return true; &#125; alert(index + \":\" + $(element).html()); &#125;); for..of（jQuery3.0版本之后提供的方式） 1234var citys = $(\"#city li\");for(li of citys)&#123; alert($(li).html());&#125; 事件绑定jQuery标准的绑定方式jquery对象.事件名称(回调函数) 1234567&lt;input type=\"text\" id=\"name\" value=\"绑定点击事件\"&gt;&lt;script&gt; $(function () &#123; $(\"#name\").click(function () &#123; alert(\"点击完成！\") &#125;); &#125;); 123456//给name绑定鼠标移进事件、绑定移除事件(链式绑定)$(\"#name\").mouseover(function () &#123; alert(\"鼠标移进！\")&#125;).mouseout(function () &#123; alert(\"鼠标移出！\")&#125;); 12345$(function () &#123; //让文本框获得焦点（不写回调函数，执行默认效果） $(\"#name\").focus(); $(\"#form\").submit();//用于提交表单 &#125;); on绑定事件、off解除绑定jquery对象.on(“事件名称”, 回调函数)jquery对象.off(“事件名称”) 1234567891011121314&lt;input type=\"button\" id=\"btn1\" value=\"使用on绑定点击事件\"&gt;&lt;input type=\"button\" id=\"btn2\" value=\"使用off解绑点击事件\"&gt;&lt;script&gt; $(function () &#123; $(\"#btn1\").on(\"click\", function () &#123; alert(\"单击事件绑定成功！\") &#125;); $(\"#btn2\").on(\"click\", function () &#123; $(\"#btn1\").off(\"click\"); alert(\"已解除单击事件！\"); // $(\"#btn1\").off();//解除所有事件 &#125;); &#125;);&lt;/script&gt; 事件切换：togglejquery对象.toggle(fn1, fn2…),注意：使用版本jquery需要引入migrate插件才能生效。 1234567891011&lt;input type=\"button\" id=\"btn\" value=\"事件切换\"&gt;&lt;br&gt;&lt;div id=\"txt\" style=\"height: 100px;width: 100px;\"&gt;切换div颜色。。。&lt;/div&gt;&lt;script&gt; $(function () &#123; $(\"#btn\").toggle(function () &#123; $(\"#txt\").css(\"backgroundColor\", \"yellow\") &#125;),function () &#123; $(\"#txt\").css(\"backgroundColor\", \"red\") &#125;; &#125;);&lt;/script&gt; 案例广告显示与隐藏 1234567891011121314151617&lt;div id=\"ad\" style=\"display: none\"&gt; &lt;img src=\"WEB-INF/img/pic1.png\" alt=\"\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script&gt; function adShow() &#123; $(\"#ad\").show(\"slow\") &#125; function adHide() &#123; $(\"#ad\").hide(\"slow\") &#125; $(function () &#123; //定义定时器,调用adShow() setTimeout(adShow, 3000); //定义定时器,adHide() setTimeout(adHide, 8000); &#125;);&lt;/script&gt; 插件（增强jQuery的功能）实现方式 $.fn.extend(object)：增强通过jQuery获取的对象的功能 $(“#id值”) 1234567891011121314151617181920212223242526272829&lt;input type=\"button\" id=\"btn-check\" value=\"点击选中复选框\" onclick=\"checkFn()\"&gt;&lt;input type=\"button\" id=\"btn-uncheck\" value=\"点击取消选中复选框\" onclick=\"uncheckFn()\"&gt;&lt;br&gt;&lt;input type=\"checkbox\" value=\"football\"&gt;足球&lt;input type=\"checkbox\" value=\"basketball\"&gt;篮球&lt;input type=\"checkbox\" value=\"volleyball\"&gt;排球&lt;script&gt; // 定义jQuery的对象插件 $.fn.extend(&#123; //定义了一个check()方法 check:function () &#123; this.prop(\"checked\", true); &#125;, //定义了一个uncheck()方法 uncheck:function () &#123; this.prop(\"checked\", false); &#125;, &#125;);//使用插件，实现选中所有复选框，取消选中 $(function () &#123; $(\"#btn-check\").click(function () &#123; $(\"input[type='checkbox']\").check(); &#125;); $(\"#btn-uncheck\").click(function () &#123; $(\"input[type='checkbox']\").uncheck(); &#125;); &#125;)&lt;/script&gt; $.extend(object)：增强通过jQuery对象自身的功能 $/jquery 12345678910111213141516&lt;script&gt; //对全局方法进行扩展，扩展min方法：求两数最小值；扩展max方法：求两数最大值 $.extend(&#123; max:function (a, b) &#123; //返回两数中最大值 return a &gt;= b ? a:b; &#125;, min:function (a, b) &#123; //返回两数中最大值 return a &gt;= b ? b:a; &#125;, &#125;); //调用全局方法 alert($.max(2, 3)); alert($.min(1, 5));&lt;/script&gt;","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JQuery","date":"2020-07-13T04:23:06.000Z","path":"2020/07/13/JQuery/","text":"概念JQuery是一个JavaScript的框架。（简化js开发） jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 使用方法： 导入jquery的js文件 使用jquery的方法即可 示例： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script src=\"WEB-INF/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\"&gt;div1...&lt;/div&gt; &lt;script&gt; alert($(\"#div1\").html()) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JQuery对象和JS对象的转换 jquery –&gt; js：jquery对象(索引) 或 jquery对象.get(索引) 1234567&lt;div id=\"div1\"&gt;div1...&lt;/div&gt; &lt;div id=\"div2\"&gt;div2...&lt;/div&gt; &lt;script&gt; var $divs = $(\"div\"); $divs[0].innerHTML = \"bbb\"; $divs.get(1).innerHTML = \"ccc\"; &lt;/script&gt; js –&gt; jquery：$(js对象) 123456789&lt;div id=\"div1\"&gt;div1...&lt;/div&gt; &lt;div id=\"div2\"&gt;div2...&lt;/div&gt; &lt;script&gt; var divs = document.getElementsByTagName(\"div\"); for (var i = 0; i &lt; divs.length; i++) &#123; //将js对象转为jquery对象，从而调用jquery的方法 $(divs[i]).html(\"aaa\") &#125; &lt;/script&gt; 选择器筛选具有相似特征的元素（标签） 基本语法 事件绑定 $(“#id值”).方法名(function(){方法体}); 123456&lt;input type=\"button\" id=\"btn1\" value=\"Click Me\"&gt;&lt;script&gt; $(\"#btn1\").click(function () &#123; alert(\"点击了按钮！\"); &#125;);&lt;/script&gt; 入口函数 123456&lt;script&gt; //jquery入口函数（DOM文档加载完毕后执行） $(function () &#123; &#125;);&lt;/script&gt; 与window.onload的区别：window.onload = function(){};只能定义一次，再次定义会被覆盖掉。入口函数可以定义多个。3. 样式控制 123456&lt;div id=\"div1\"&gt;div1...&lt;/div&gt;&lt;script&gt; $(function () &#123; $(\"#div1\").css(\"backgroundColor\", \"red\"); &#125;);&lt;/script&gt; 分类： 基本选择器 标签选择器（元素选择器） 语法：$(“html标签名”)获得所有匹配标签名的子元素 id选择器 语法：$(“id的属性值”)获得与指定id属性值匹配的元素 类选择器 语法：$(“.class的属性值”)获得与指定class属性值匹配的元素 并集选择器 语法：$(“选择器1, 选择器2…”)获取多个选择器选中的所有元素 示例： 1234567891011121314151617181920&lt;input type=\"button\" id=\"btn1\" value=\"改变id为one的元素背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn2\" value=\"改变元素名为&lt;div&gt;的所有元素背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn3\" value=\"改变class为mini的所有元素背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn4\" value=\"改变所有的&lt;span&gt;元素和id为two的元素背景色为红色\"&gt;&lt;script&gt; $(function () &#123; $(\"#btn1\").click(function ()&#123; $(\"#one\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn2\").click(function ()&#123; $(\"div\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn3\").click(function ()&#123; $(\".mini\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn4\").click(function ()&#123; $(\"span, #two\").css(\"backgroundColor\", \"red\"); &#125;); &#125;);&lt;/script&gt; 层级选择器 后代选择器 语法：$(“A B”)选择A元素内部的所有B元素 子选择器 语法：$(“A &gt; B”)选择A元素内部的所有B子元素 示例： 123456789101112&lt;input type=\"button\" id=\"btn1\" value=\"改变&lt;body&gt;内所有&lt;div&gt;的背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn2\" value=\"改变&lt;body&gt;内子&lt;div&gt;的背景色为红色\"&gt;&lt;script&gt; $(function () &#123; $(\"#btn1\").click(function ()&#123; $(\"body div\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn2\").click(function ()&#123; $(\"body &gt; div\").css(\"backgroundColor\", \"red\"); &#125;); &#125;);&lt;/script&gt; 属性选择器 属性名称选择器 语法：$(“A[属性名]”)包含指定属性的选择器 属性选择器 语法：$(“A[属性名=’值’]”)包含指定属性等于指定值的选择器 复合属性选择器 语法：$(“A[属性名=’值’][]…”)包含多个属性条件的选择器 示例： 1234567891011121314151617181920212223242526272829303132&lt;input type=\"button\" id=\"btn1\" value=\"含有属性title的div元素背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn2\" value=\"属性title值等于test的div元素背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn3\" value=\"属性title值不等于test的div元素背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn4\" value=\"属性title值以te开始的div元素背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn5\" value=\"属性title值以est结束的div元素背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn6\" value=\"属性title值含有es的div元素背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn7\" value=\"选取有属性id的div元素，然后在结果中选取属性值title值含有es的div元素背景色为红色\"&gt;&lt;script&gt; $(function () &#123; $(\"#btn1\").click(function ()&#123; $(\"div[title]\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn2\").click(function ()&#123; $(\"div[title = 'test']\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn3\").click(function ()&#123; $(\"div[title != 'test']\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn4\").click(function ()&#123; $(\"div[title ^= 'te']\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn5\").click(function ()&#123; $(\"div[title $= 'est']\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn6\").click(function ()&#123; $(\"div[title *= 'es']\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn7\").click(function ()&#123; $(\"div[id][title *= 'es']\").css(\"backgroundColor\", \"red\"); &#125;); &#125;);&lt;/script&gt; 过滤选择器 首元素选择器 语法：:first获得选择的元素中第一个元素 尾元素选择器 语法：:last获得选择的元素中最后一个元素 非元素选择器 语法：:not(selector)不包括指定内容的元素 偶数选择器 语法：:even 偶数, 从0开始计数 奇数选择器 语法：:odd 奇数, 从0开始计数 等于选择器 语法：:eq(index)指定索引元素 大于选择器 语法：:gt(index)大于指定索引元素 小于选择器 语法：:lt(index)小于指定索引元素 标题选择器 语法：:header 获得标题(h1~h6)元素，固定写法 示例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;input type=\"button\" id=\"btn1\" value=\"改变第一个div元素的背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn2\" value=\"改变最后一个div元素的背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn3\" value=\"改变class不为one的所有div元素的背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn4\" value=\"改变索引值为偶数的的div元素的背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn5\" value=\"改变索引值为奇数的的div元素的背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn6\" value=\"改变索引值大于3的的div元素的背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn7\" value=\"改变索引值等于3的的div元素的背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn8\" value=\"改变索引值小于3的的div元素的背景色为红色\"&gt;&lt;input type=\"button\" id=\"btn9\" value=\"改变所有标题元素的背景色为红色\"&gt;&lt;script&gt; $(function () &#123; $(\"#btn1\").click(function ()&#123; $(\"div:first\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn2\").click(function ()&#123; $(\"div:last\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn3\").click(function ()&#123; $(\"div:not(.one)\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn4\").click(function ()&#123; $(\"div:even\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn5\").click(function ()&#123; $(\"div:odd\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn6\").click(function ()&#123; $(\"div:gt(3)\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn7\").click(function ()&#123; $(\"div:eq(3)\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn8\").click(function ()&#123; $(\"div:lt(3)\").css(\"backgroundColor\", \"red\"); &#125;); $(\"#btn9\").click(function ()&#123; $(\":header\").css(\"backgroundColor\", \"red\"); &#125;); &#125;);&lt;/script&gt; 表单过滤选择器 可用元素选择器 语法：:enabled获得可用元素 不可用元素选择器 语法：:disabled获得不可用元素 选中选择器 语法：:checked获得单选/复选框中的元素 选中选择器 语法：:selected获得下拉框选中的元素 示例： 123456789101112131415161718192021&lt;input type=\"button\" id=\"btn1\" value=\"利用jQuery对象的val()方法改变表单内可用&lt;input&gt;元素的值\"&gt;&lt;input type=\"button\" id=\"btn2\" value=\"利用jQuery对象的val()方法改变表单内不可用&lt;input&gt;元素的值\"&gt;&lt;input type=\"button\" id=\"btn3\" value=\"利用jQuery对象的length属性获取复选框选中的个数\"&gt;&lt;input type=\"button\" id=\"btn4\" value=\"利用jQuery对象的length属性获取下拉框选中的个数\"&gt;&lt;script&gt; $(function () &#123; $(\"#btn1\").click(function ()&#123; $(\"input[type='text']:enabled\").val(\"aaa\"); &#125;); $(\"#btn2\").click(function ()&#123; $(\"input[type='text']:disabled\").val(\"aaa\"); &#125;); $(\"#btn3\").click(function ()&#123; alert($(\"input[type='checkbox']:checked\").length); &#125;); $(\"#btn4\").click(function ()&#123; //要获取的时option的选中个数而不是下拉框的个数 alert($(\"select &gt; option:selected\").length); &#125;); &#125;);&lt;/script&gt; DOM操作内容操作 html()：获取/设置元素的标签体内容 1234//获取$(\"#id值\").html();//设置,直接替换源码$(\"#id值\").html(\"aaa\") text()：获取/设置元素的标签体纯文本内容 1234//获取$(\"#id值\").text();//设置$(\"#id值\").text(\"aaa\") val()：获取/设置元素的value属性值 1234//获取$(\"#id值\").val();//设置$(\"#id值\").val(\"aaa\") 属性操作 通用属性操作 attr()：获取/设置元素的属性 removeAttr()：删除元素的属性 prop()：获取/设置元素的属性 removeProp：删除元素的属性 attr和prop的区别： - 操作元素的固有属性（元素自带的属性），建议用prop。（如：href、src） - 操作自定义属性，建议用attr。（如：aaa） 123456789101112131415161718192021&lt;div&gt; &lt;ul&gt; &lt;li id=\"bj\" name=\"beijing\" xxx=\"yyy\"&gt;北京&lt;/li&gt; &lt;li id=\"tj\" name=\"tianjin\"&gt;天津&lt;/li&gt; &lt;/ul&gt; &lt;input type=\"checkbox\" id=\"hobby\"&gt;&lt;/div&gt;&lt;script&gt; $(function () &#123; //获取 alert($(\"#bj\").attr(\"name\"));//li中name为自定义属性 //设置 $(\"#bj\").attr(\"name\", \"首都\");//此处修改的是name属性 //增加aaa属性，值为bbb $(\"#bj\").attr(\"aaa\", \"bbb\"); //删除xxx属性，并检验xxx属性是否存在 $(\"#bj\").removeAttr(\"aaa\", \"bbb\"); //获取hobby的选中状态 alert($(\"#hobby\").prop(\"checked\"));//checked和option不能用attr获取到 &#125;);&lt;/script&gt; 对class属性操作 addClass：添加Class属性值 removeClass：删除Class属性值 toggleClass：切换Class属性值。（如：元素对象上存在class=”one”,则删除。若不存在class=”one”，则添加。） 123456789101112131415161718192021222324252627282930&lt;input type=\"button\" id=\"btn1\" value=\"采用属性增加样式（改变id=one的样式）\"&gt;&lt;input type=\"button\" id=\"btn2\" value=\"addClass\"&gt;&lt;input type=\"button\" id=\"btn3\" value=\"removeClass\"&gt;&lt;input type=\"button\" id=\"btn4\" value=\"切换样式\"&gt;&lt;input type=\"button\" id=\"btn5\" value=\"通过css()获得id=one背景颜色\"&gt;&lt;input type=\"button\" id=\"btn6\" value=\"通过css()设置id=one背景颜色为绿色\"&gt;&lt;br&gt;&lt;div id=\"one\" style=\"background-color:cyan;\"&gt;aaa&lt;/div&gt;&lt;script&gt; $(function () &#123; $(\"#btn1\").click(function () &#123; $(\"#one\").prop(\"class\", \"aaa\");//class=\"aaa\"事先设置了样式 &#125;); $(\"#btn2\").click(function () &#123; $(\"#one\").addClass(\"aaa\");//class=\"aaa\"事先设置了样式 &#125;); $(\"#btn3\").click(function () &#123; $(\"#one\").removeClass(\"aaa\");//class=\"aaa\"事先设置了样式 &#125;); $(\"#btn4\").click(function () &#123; $(\"#one\").toggleClass(\"aaa\");//class=\"aaa\"事先设置了样式 &#125;); $(\"#btn5\").click(function () &#123; alert($(\"#one\").css(\"backgroundColor\"));//class=\"aaa\"事先设置了样式 &#125;); $(\"#btn6\").click(function () &#123; $(\"#one\").css(\"backgroundColor\", \"green\");//class=\"aaa\"事先设置了样式 &#125;); &#125;);&lt;/script&gt; CRUD操作 append()：父元素将子元素追加到末尾。 （对象1.append(对象2)：将对象2追加到对象1的末尾）。 prepend()：父元素将子元素插入到开头。 （对象1.prepend(对象2)：将对象2插入到对象1的开头）。 appendTo()：父元素将子元素插入到开头。 （对象1.prepend(对象2)：将对象1添加到到对象2的末尾）。 prependTo()：父元素将子元素插入到开头。 （对象1.prepend(对象2)：将对象1添加到到对象2的开头）。 after()：添加元素a到元素b后。 （对象1.after(对象2)：将对象1添加到到对象2后，在同一级。） before()：添加元素a到元素b前。 （对象1.after(对象2)：将对象1添加到到对象2前，在同一级。） insertAfter()：添加元素a到元素b前。 （对象1.after(对象2)：将对象1插入到到对象2后，在同一级。） insertBefore()：添加元素a到元素b后。 （对象1.after(对象2)：将对象1插入到到对象2前，在同一级。） remove()：移除元素。 （对象.remove()：将对象删除。） empty()：清空元素的所有后代元素。 （对象.empty()：将对象的后代元素全部清空，但保留当前对象及其属性节点。） 案例 隔行换色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;style&gt; td&#123; text-align: center; &#125;&lt;/style&gt; &lt;table id=\"tab1\" border=\"1\" width=\"800\" align=\"center\"&gt; &lt;tr&gt; &lt;td colspan=\"5\"&gt;&lt;input type=\"button\" value=\"删除\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=\"checkbox\"&gt;&lt;/th&gt; &lt;th&gt;分类ID&lt;/th&gt; &lt;th&gt;分类名称&lt;/th&gt; &lt;th&gt;分类描述&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;分类1&lt;/td&gt; &lt;td&gt;aaa&lt;/td&gt; &lt;td&gt;&lt;a href=\"\"&gt;修改&lt;/a&gt;&amp;nbsp&amp;nbsp&amp;nbsp&lt;a href=\"\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;分类2&lt;/td&gt; &lt;td&gt;bbb&lt;/td&gt; &lt;td&gt;&lt;a href=\"\"&gt;修改&lt;/a&gt;&amp;nbsp&amp;nbsp&amp;nbsp&lt;a href=\"\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;分类3&lt;/td&gt; &lt;td&gt;ccc&lt;/td&gt; &lt;td&gt;&lt;a href=\"\"&gt;修改&lt;/a&gt;&amp;nbsp&amp;nbsp&amp;nbsp&lt;a href=\"\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;分类4&lt;/td&gt; &lt;td&gt;ddd&lt;/td&gt; &lt;td&gt;&lt;a href=\"\"&gt;修改&lt;/a&gt;&amp;nbsp&amp;nbsp&amp;nbsp&lt;a href=\"\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;script&gt; //需求：将数据行的奇数行背景色设置为pink，偶数行背景色为yellow $(function () &#123; //1. 获取所有奇数行tr $(\"tr:gt(1):odd\").css(\"backgroundColor\", \"pink\"); //2. 获取所有偶数行tr $(\"tr:gt(1):even\").css(\"backgroundColor\", \"yellow\"); &#125;);&lt;/script&gt; 全选全部选 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; //需求：全选全不选 function selectAll(obj) &#123; $(\".itemSelect\").prop(\"checked\", obj.checked); &#125;&lt;/script&gt; &lt;table id=\"tab1\" border=\"1\" width=\"800\" align=\"center\"&gt; &lt;tr&gt; &lt;td colspan=\"5\"&gt;&lt;input type=\"button\" value=\"删除\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=\"checkbox\" onclick=\"selectAll(this)\"&gt;&lt;/th&gt; &lt;th&gt;分类ID&lt;/th&gt; &lt;th&gt;分类名称&lt;/th&gt; &lt;th&gt;分类描述&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" class=\"itemSelect\"&gt;&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;分类1&lt;/td&gt; &lt;td&gt;aaa&lt;/td&gt; &lt;td&gt;&lt;a href=\"\"&gt;修改&lt;/a&gt;&amp;nbsp&amp;nbsp&amp;nbsp&lt;a href=\"\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" class=\"itemSelect\"&gt;&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;分类2&lt;/td&gt; &lt;td&gt;bbb&lt;/td&gt; &lt;td&gt;&lt;a href=\"\"&gt;修改&lt;/a&gt;&amp;nbsp&amp;nbsp&amp;nbsp&lt;a href=\"\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" class=\"itemSelect\"&gt;&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;分类3&lt;/td&gt; &lt;td&gt;ccc&lt;/td&gt; &lt;td&gt;&lt;a href=\"\"&gt;修改&lt;/a&gt;&amp;nbsp&amp;nbsp&amp;nbsp&lt;a href=\"\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" class=\"itemSelect\"&gt;&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;分类4&lt;/td&gt; &lt;td&gt;ddd&lt;/td&gt; &lt;td&gt;&lt;a href=\"\"&gt;修改&lt;/a&gt;&amp;nbsp&amp;nbsp&amp;nbsp&lt;a href=\"\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 下拉列表选中条目左右移动 1234567891011121314151617181920212223242526272829303132333435&lt;style&gt; .border&#123; height: 100px; width: 300px; background-color: red; &#125; #leftSelect, #btn, #rightSelect&#123; float: left; &#125;&lt;/style&gt;&lt;script&gt; $(function () &#123; $(\"#toRight\").click(function () &#123; $(\"#rightSelect\").append($(\"#leftSelect &gt; option:selected\")); &#125;); $(\"#toLeft\").click(function () &#123; $(\"#rightSelect &gt; option:selected\").appendTo($(\"#leftSelect\")); &#125;); &#125;);&lt;/script&gt; &lt;div class=\"border\"&gt; &lt;select id=\"leftSelect\" multiple=\"multiple\"&gt; &lt;option&gt;张三&lt;/option&gt; &lt;option&gt;李四&lt;/option&gt; &lt;option&gt;王五&lt;/option&gt; &lt;option&gt;赵六&lt;/option&gt; &lt;/select&gt; &lt;div id=\"btn\"&gt; &lt;input type=\"button\" id=\"toRight\" value=\"--&gt;\"&gt;&lt;br&gt; &lt;input type=\"button\" id=\"toLeft\" value=\"&lt;--\"&gt; &lt;/div&gt; &lt;select id=\"rightSelect\" multiple=\"multiple\"&gt; &lt;option&gt;钱七&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Filter过滤器","date":"2020-07-10T09:28:39.000Z","path":"2020/07/10/Filter过滤器/","text":"Filter:过滤器作用：一般用于完成一些通用操作。如登陆验证、统一编码处理、敏感字符过滤等。 使用方法：1. 定义一个类实现Filter 2. 复写方法 3. 配置拦截路径 示例： 123456789101112131415161718import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;@WebFilter(\"/*\")//访问所有资源之前，都会执行该过滤器public class FilterDemo implements Filter &#123; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; System.out.println(\"该过滤器执行啦！！！\"); chain.doFilter(req, resp);//放行 &#125; @Override public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 注意事项 web.xml配置 12345678910&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!--引入类--&gt; &lt;filter-class&gt;top.rainbowcat.web.filter.FilterDemo1top.rainbowcat.web.filter.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!--拦截路径--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器执行流程 执行过滤器 执行放行后的资源 执行放行后的代码 1234567@Overridepublic void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; //该处对request对象请求消息进行增强 System.out.println(\"该过滤器执行啦！！！\"); chain.doFilter(req, resp);//放行 //该处对response对象响应消息进行增强&#125; 过滤器生命周期方法 init方法：服务器启动后，会创建Filter对象，调用init方法。用于加载资源。 destroy方法：在服务器关闭后，Filter对象被销毁。如果服务器时正常关闭，则会执行destroy方法。用于释放资源。 doFilter方法：每一次请求被拦截资源时会执行。 过滤器配置详解 拦截路径的配置 具体的资源路径，如：/index.jsp 只有访问index.jsp时，过滤器才会被执行 拦截目录，如：/user/* 访问/user下的所有资源时，过滤器才会被执行 后缀名拦截，如：*.jsp 访问所有后缀名为.jsp资源时，过滤器才会被执行 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 拦截方式的配置：资源被访问的方式 注解配置 设置dispatchType属性 REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源，只有转发访问到的资源会被拦截 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 示例： 12//访问所有资源之前，都会执行该过滤器@WebFilter(value = \"/*\", dispatcherTypes =DispatcherType.REQUEST) web.xml配置：只需增加属性值标签即可 示例： 123456&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!--拦截路径--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 过滤器链（配置多个过滤器） 执行顺序：如果有两个过滤器（过滤器1、过滤器2）过滤器1 –&gt; 过滤器2 –&gt; 资源执行 –&gt; 过滤器2 –&gt; 过滤器1示例：第一个过滤器 123456789101112131415@WebFilter(\"/*\")public class FilterDemo1 implements Filter &#123; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; System.out.println(\"FilterDemo1执行啦！！！\"); chain.doFilter(req, resp);//放行 System.out.println(\"FilterDemo1回来啦！！！\"); &#125; @Override public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 第二个过滤器 1234567891011121314151617@WebFilter(\"/*\")public class FilterDemo2 implements Filter &#123; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; //该处对request对象请求消息进行增强 System.out.println(\"FilterDemo2执行啦！！！\"); chain.doFilter(req, resp);//放行 //该处对response对象响应消息进行增强 System.out.println(\"FilterDemo2回来啦！！！\"); &#125; @Override public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 执行结果： FilterDemo1执行啦！！！ FilterDemo2执行啦！！！ FilterDemo2回来啦！！！ FilterDemo1回来啦！！！ 过滤器先后顺序问题： 注解配置：按照类名的字符串比较规则比较，值小的先执行。如：AFilter和BFilter，AFilter就先执行。 web.xml配置：按照编写顺序从上到下执行。 案例登陆验证需求分析： 访问资源时验证是否登录 如果已经登陆，直接放行 没有登陆，则跳转到登陆页面 代码实现： 1234567891011121314151617181920212223242526@Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; //强制转换 HttpServletRequest request = (HttpServletRequest) req; //1. 获取资源请求路径 String uri = request.getRequestURI(); //2. 判断是否包含登陆相关的资源路径,要注意排除掉css/js/图片/验证码等资源 if (uri.contains(\"/login.jsp\") || uri.contains(\"/loginServlet\") || uri.contains(\"/css/\") || uri.contains(\"/js/\") || uri.contains(\"/fonts/\") || uri.contains(\"/checkCodeServlet\"))&#123; //包含，用户正要登陆，放行 chain.doFilter(req, resp); &#125;else &#123; //不包含，用户需要登陆验证 //3. 从session中获取用户登陆信息 Object user = request.getSession().getAttribute(\"user\"); if (user != null)&#123; //登陆了，放行 chain.doFilter(req, resp); &#125;else &#123; //没有登陆，跳转登陆页面 request.setAttribute(\"login_msg\", \"您尚未登陆，请登陆！\"); request.getRequestDispatcher(\"login.jsp\").forward(request, resp); &#125; &#125; &#125; 敏感词汇过滤需求分析： 录入数据时验证是否含有敏感数据 敏感词汇参考《敏感词汇.txt》 如果有敏感词汇，替换为*** 增强对象的功能：设计模式 设计模式：一些通用的解决固定问题的方式。 装饰模式 代理模式 概念： 真实对象：被代理的对象 代理对象： 代理模式：代理对象代理真实对象，达到增强真实对象的目的。 实现方式： 静态代理：有一个类文件藐视代理模式 在内存中形成代理类 实现步骤： 代理对象和真实对象实现相同的接口 代理对象 = Proxy.newProxyInstance(); 使用代理对象调用方法 增强方法 代码实现：过滤器部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 敏感词汇过滤器 */@WebFilter(\"/*\")public class SensitiveWordsFilter implements Filter &#123; @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; //1.创建代理对象，增强getParameter方法 ServletRequest proxy_req = (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //增强getParameter方法 //判断是否时getParameter方法 if (method.getName().equals(\"getParameter\"))&#123; //增强返回值 //获取返回值 String value = (String) method.invoke(req, args); if (value != null)&#123; for (String str : list)&#123; if (value.contains(str))&#123; value = value.replace(str, \"***\"); &#125; &#125; &#125; return value; &#125; //判断方法是否为getParameterMap //判断方法是否为getParameterValue return method.invoke(req, args); &#125; &#125;); //2.放行,以定要用代理对象！！！而不是req chain.doFilter(proxy_req, resp); &#125; private List&lt;String&gt; list = new ArrayList&lt;String&gt;();//敏感词汇集合 @Override public void init(FilterConfig config) throws ServletException &#123; try&#123; //1.加载文件的真实路径 ServletContext servletContext = config.getServletContext(); String realPath = servletContext.getRealPath(\"/WEB-INF/classes/敏感词汇.txt\"); //2.读取文件 BufferedReader br = new BufferedReader(new FileReader(realPath)); //3.将文件的每一行数据添加到list集合 String line = null; while ((line = br.readLine())!=null)&#123; list.add(line); &#125; br.close(); System.out.println(list); &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 测试代码 1234567891011121314@WebServlet(\"/textServlet\")public class TextServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter(\"name\"); String msg = request.getParameter(\"msg\"); System.out.println(name+\":\"+msg); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 在地址栏进行传参，控制台查看输出情况即可。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"EL使用","date":"2020-04-07T04:41:28.000Z","path":"2020/04/07/EL表达式/","text":"EL表达式 概念：Expression Language表达式语言 作用：替换和简化jsp页面中的Java代码 语法：${表达式} 注意：jsp默认支持el表达式 使用： 运算 获取值 运算 运算符 算数运算符：+ - * /(div) %(mod) 比较运算符：&gt; &lt; &gt;= &lt;= == != 逻辑运算符：&amp;&amp;(and) ||(or) !(not) 空运算符：empty ${empty list}：用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${not empty str}：用于判断字符串、集合、数组对象是否不为null并且长度&gt;0 1234567891011121314151617181920212223242526272829&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;算数运算&lt;/h3&gt; $&#123;3 + 4&#125;&lt;br&gt; $&#123;3 / 4&#125;&lt;br&gt; $&#123;3 div 4&#125;&lt;br&gt; $&#123;3 % 4&#125;&lt;br&gt; $&#123;3 mod 4&#125;&lt;br&gt; &lt;h3&gt;比较运算&lt;/h3&gt; $&#123;3 == 4&#125;&lt;br&gt; &lt;h3&gt;逻辑运算&lt;/h3&gt; $&#123;3 &gt; 4 &amp;&amp; 3 &lt; 4&#125;&lt;br&gt; $&#123;3 &gt; 4 and 3 &lt; 4&#125;&lt;br&gt; &lt;h3&gt;empty运算符&lt;/h3&gt; &lt;% String str = \"abc\"; request.setAttribute(\"str\", str); List list = new ArrayList(); request.setAttribute(\"list\", list); %&gt; $&#123;empty str&#125; $&#123;not empty list&#125; &lt;/body&gt;&lt;/html&gt; 获取值 el表达式只能从域对象中获取值 语法： ${域名称.键名}：从指定域中获取指定的键的值。 域名称： pageScope –&gt; pageContext requestScope –&gt; request sessionScope –&gt; session applicationScope –&gt; application(ServletContext) 举例：在request域中存储了name=张三 获取：${reques.name} 1234567891011121314151617&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;获取域中的值&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% request.setAttribute(\"name\", \"张三\"); session.setAttribute(\"age\", \"23\"); %&gt;&lt;h3&gt;获取值&lt;/h3&gt;$&#123;requestScope.name&#125;$&#123;sessionScope.age&#125;&lt;%-- 获取不到值时显示空字符串 --%&gt;$&#123;sessionScope.haha&#125;&lt;/body&gt;&lt;/html&gt; ${键名}：表示依次从最小的域中查找是否有该键的对应值，直到找到为止。 获取对象、List集合、Map集合中的值 对象：${域名称.键名.属性名}（本质上会去调用对象的getter方法） List集合：${域名称.键名[索引]}（索引超出数组长度，返回空字符串） Map集合：${域名称.键名.key名称}（或：${域名称.键名[“key名称”]}） 隐式对象pageContext${pageContext.request}在jsp页面中动态获取虚拟目录${pageContext.request.contextPath} JSTL标签 概念：JavaServer Page Tag Library JSP标准标签库 作用：用于简化和替换jsp页面的java代码 使用步骤： 导入jstl相关jar包 引入标签库：taglib指令：&lt;%@ taglib &gt; 使用标签 常用的JSTL标签 if：相当于Java代码的if语句 choose：相当于Java代码的switch语句 foreach：相当于Java代码的for语句","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JavaScript学习笔记（二）","date":"2020-03-20T03:13:18.000Z","path":"2020/03/20/BOM和DOM/","text":"BOM &amp; DOMBOM概念：Browser Object Model浏览器对象模型，将浏览器的各个组成部分封装成对象。 组成：Window：窗口对象 创建Window的对象不需要创建，直接可以调用方法。 方法 与弹出框有关的方法：alert()： 显示带有一段消息和一个确认按钮的警告框。confirm()： 显示带有一段消息以及确认按钮和取消按钮的对话框。返回值为false或true。prompt()： 显示可提示用户输入的对话框。 与打开关闭有关的方法：open(): 打开一个新浏览器窗口对象，可加参数close(): 关闭浏览器窗口 与定时器有关的方法：setTimeout()： 在指定的毫秒数后调用函数或计算表达式。（一次性定时器） var id = setTimeout(“js代码”,毫秒值); clearTimeout()： 取消由setTimeout()设置的timeout。 clearTimeout(“js代码”,毫秒值); setInterval()： 按照指定的周期（以毫秒计）来调用函数或计算表达式。 var id = setInterval(id); clearInterval()： 取消由setInterval()设置的timeout。 clearInterval(id); 轮播图小案例： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"pic\" src=\"images/pic1.jpg\"&gt; &lt;script&gt; var number = 1; function fun()&#123; number++; if (number &gt; 3)&#123; number = 1; &#125; var pic = document.getElementById(\"pic\"); pic.src = \"images/pic\"+ number +\".jpg\" &#125; setInterval(fun,3000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 属性 获取其他BOM对象historylocationnavigatorscreen 获取DOM对象document Location：地址栏对象 创建（获取）： window.location location 方法reload(): 重新加载当前文档。 属性href： 设置或返回完整的URL。 倒计时跳转页面小案例： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; p&#123; text-align: center; &#125; span&#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;span id=\"time\"&gt;5&lt;/span&gt;秒后跳转至首页... &lt;/p&gt; &lt;script&gt; var second = 5; var time = document.getElementById(\"time\"); function tim()&#123; second--; if (second &lt;= 0)&#123; location.href = \"https://www.baidu.com\"; &#125; time.innerHTML = second + \"\"; &#125; setInterval(tim,1000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; History：历史记录对象 创建 window.history history 方法 back()： 加载history列表中的前一个URL。 forward()： 加载history列表中的下一个URL。 go()： 加载history列表中的某个具体页面。 history.go(1); //前进一个历史记录的页面（参数为负则倒退） 属性length： 返回当前窗口历史列表中的URL数量。 DOMDocument Object Model 文档对象模型W3C DOM标准被分为3个不同的部分： 核心DOM：针对任何结构化文档的标准模型 XML DOM：针对XML文档的标准模型 HTML DOM：针对HTML文档的标准模型功能 控制HTML文档的内容。 document.getElementByID(“id值”) // 通过元素的id获取元素对象 操作Element对象： 修改标签的属性值 修改标签体内容 核心DOM模型 Document：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 Node：节点对象（其他5个对象的父对象） Document：文档对象 创建（获取）：通过window来获取和创建 window.document document 方法： 获取Element对象 getElementById()：根据id属性值获取元素对象。id属性值一般唯一。 getElementByTagName()：根据元素名称获取元素对象。返回值是一个数组。 getElementByClassName()：根据Class属性值获取元素对象。返回值是一个数组。 getElementByName()：根据name属性值获取元素对象。返回值是一个数组。 创建其他DOM对象 creatAttribute(name) creatComment() creatElement() creatTextNode() Element：元素对象 创建：通过document来获取和创建 方法： removeAttribute()：删除属性 setAttribute()：设置属性 Node：节点对象是整个DOM的主要数据类型。节点对象代表文档树中的一个单独的节点。节点可以是元素节点、属性节点、文本节点等。 方法： CRUD dom树：1. appendChild()：向节点的子节点列表结尾添加新的子节点 2. removeChild()：删除（并返回）当前节点的指定节点 3. replaceChild()：用新节点替换一个子结点 事件 功能：组件被执行了某些操作后，触发某些代码的执行。 如何绑定事件： 直接在HTML标签上指定事件的属性（操作），属性值就是js代码。例如onclick（单击事件） 通过js获取元素对象，指定事件属性，设置一个函数。 document.getElementByID(“…”) 常见的事件 点击事件： onclick：单击事件 ondblclick：双击事件 焦点事件： onblur：失去焦点 onfocus：元素获得焦点 加载事件： onload：一张页面或一幅图像完成加载 鼠标事件： onmousedown：鼠标按钮被按下 onmouseup：鼠标按键被松开 onmousemove：鼠标被移开 onmouseover：鼠标移到某个元素之上 onmouseout：鼠标从某个元素移开 键盘事件： onkeydown：某个键盘被按下 onkeyup：某个键盘被松开 onkeypress：某个键盘被按下并松开 选中和改变： onchange：域的内容被改变 onselect：文本被选中 表单事件： onsubmit：确认按钮被点击 onreset：重置按钮被点击","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JavaScript学习笔记（一）","date":"2020-02-26T08:45:18.000Z","path":"2020/02/26/JavaScript学习笔记/","text":"JavaScript概念：客户端脚本语言，不需要编译直接就可以被浏览器解析执行。运行在客户端浏览器，每个浏览器都有JavaScript的解析引擎。由ECMAScript、BOM和DOM构成。 功能：可以增强用户和HTML页面的交互过程，可以控制HTML元素，让页面有一些动态效果，增强用户体验。 ECMAScript：客户端脚本语言标准。基本语法 与HTML的结合方式 内部js：定义&lt;script&gt;标签，在标签体中写js代码。 &lt;script&gt;js代码 外部js：定义&lt;script&gt;标签，通过src属性引入外部的js文件。 &lt;script src=”文件名.js”&gt; 注意：&lt;script&gt;标签可以定义在HTML页面的任意位置、也可以定义多个，但是定义的位置会影响执行顺序。 注释 123456&lt;script&gt;&#x2F;&#x2F;单行注释&#x2F;*多行注释*&#x2F;&lt;&#x2F;script&gt; 数据类型 原始数据类型（基本数据类型）： number：数字。整数/小数/NaN string：字符串。字符/字符串 boolean：true/false null：一个对象为空的占位符 undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined 引用数据类型（对象） 变量JavaScript的变量是弱类型变量，在申请变量存储空间时不定义数据类型。语法： var 变量名=变量值 运算符 一元运算符 ++：自增 –：自减 +(-)：正（负）号。在js中如果运算数不是运算所要求的类型，js引擎会自动将运算数进行类型转换。例如： var b = +”123”; //原本b应该是字符串类型123，但是由于正号的转换，b变成了数值类型123var a = +”abc” //字符串abc会被转为NaNvar c = true //转为1var d = false //转为0 算术运算符+ 、- 、* 、/ 赋值运算符= 比较运算符&gt; 、&lt; 、&gt;= 、&lt;= 、== 、===(全等于) 类型相同直接比较，字符串的比较按照字典顺序逐一比较，直到比出大小为止。 3&gt;4 //false“abc”&gt;”acd” //第二位c大于b 返回false 类型不同，先转换类型在比较 “123”&gt;123 //false“123”==123 //false 由于类型不同，不能直接比，返回false。此时要用===（全等于） 逻辑运算符&amp;&amp; 、|| 、!注意：其他类型转boolean number：0或NaN为false，其余为true string：除了空字符串（””），其余为true null&amp;undefined：都是假 对象：所有对象都是true 三元运算符? 、: var a = 3; var b = 4; var c = a &gt; b ? 1 : 0; // 如果a&gt;b 则c=1，否则c=0 流程控制语句 if …else… switch 在js中可以接受任意类型的数据 while do…while for 九九乘法表小项目： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;九九乘法表&lt;/title&gt; &lt;style&gt; td&#123; border: 1px solid; &#125; &lt;/style&gt; &lt;script&gt; document.write(\"&lt;table align='center'&gt;\"); for (var i = 1; i &lt;= 9; i++)&#123; document.write(\"&lt;tr&gt;\") for (var j = 1; j &lt;= i; j++)&#123; document.write(\"&lt;td&gt;\") document.write(i + \"*\" + j + \"=\" + (i*j) +\"&amp;nbsp;&amp;nbsp;&amp;nbsp;\"); document.write(\"&lt;/td&gt;\") &#125; document.write(\"&lt;br&gt;\"); document.write(\"&lt;/tr&gt;\") &#125; document.write(\"&lt;/table&gt;\") &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 基本对象Function函数(方法)对象： 创建： var 方法名 = new Function(参数列表, 方法体); function 方法名称（参数列表）{ 方法体} var 方法名称 = function(形式参数列表){方法体} 方法 属性： length：代表形参个数 特点： 方法定义时，形参的类型不用写,返回值也不用写。 方法是一个对象，定义名称相同的方法，会覆盖之前的。 在js中方法的调用值与方法名称有关，与参数列表无关。 在方法声明中，有一个隐藏的内置对象（数组），arguments封装所有的实际参数。 求任意个数的和： 1234567891011&lt;script&gt; function add()&#123; var sum &#x3D; 0; for (var i &#x3D; 0; i &lt; arguments.length; i++)&#123; sum +&#x3D; arguments[i]; &#125; return sum; &#125; var sum &#x3D; add(1, 2, 3, 4); alert(sum);&lt;&#x2F;script&gt; 调用： 方法名称（实际参数列表）; Array： 创建： var arr = new Array(元素列表); var arr = new Array(默认长度); var arr = [元素列表]; 方法： join()： 将数组中的元素按照指定的分隔符拼接为字符串 push()：列表末尾进行追加 属性： length：代表数组的长度 特点： JS中，数组元素的类型可变 JS中，数组的长度可变 BooleanDate： 创建： var date = new Date(); 方法： toLocaleString()：返回当前date对象对应的时间本地字符串格式 getTime()：返回当前日期对象描述的时间至1970年1月1日零点的毫秒值差（用于时间戳） Math： 方法： random()：返回0~1的随机数 ceil(x)：对数字向上取整 floor(x)：对数字向下取整 round(x)：把数字四舍五入为最接近的整数 属性： PI：圆周率 特点：Math对象不用创建，直接使用。 Number： 创建： var arr = new Array(元素列表); 方法： 属性： length：代表数组的长度 特点： String：RegExp：正则表达式： 定义字符串的组成规则。 单个字符：[]如：[a] [ab] [a-zA-Z0-9]特殊符号代表特殊含义的单个字符： \\d：单个数字字符[0-9] \\w：单个单词字符[a-zA-Z0-9] 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：表示出现1次或多次 {m,n}：表示m&lt;=数量&lt;=n m如果缺省{,n}：最多n次 n如果缺省{m,}：最少n次 开始结束符号： ^：开始 $：结束 正则对象： 创建 var reg = new RegExp(“正则表达式”); var reg = /正则表达式/; 方法 test()：验证指定的字符串是否符合定义的规范，返回值为Boolean Global: 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。方法名(); 方法： encodeURI()：URL编码，只对汉字进行编码 decodeURI()：URL解码 encodeURIComponent()：URL编码，编码的字符更多 dncodeURIComponent()：URL解码 parseInt()：将字符串转为数字。逐一判断每一个字符是否为数字，直到不是数字位置，将前边数字部分转为number。 “123” –&gt; 123“123abc” –&gt; 123 isNaN()：判断一个值是否是NaN。NaN参与的==比较返回结果均为false，只能通过该方法判断。 eval()：将JavaScript的字符串转为脚本并执行。 var jscode = “alert(123)”; //原本为字符串eval(jscode); //通过eval()方法解析字符串片段","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"HTML标签回顾","date":"2020-02-19T09:20:18.000Z","path":"2020/02/19/HTML学习笔记/","text":"文本标签 i：斜体 b：加粗 font：字体标签 结合CSS使用的标签 div：每一个div占满一整行。块级标签。 表格标签 table：表格 width 宽度 border 边框 cellpadding 定义内容与单元格之间的距离 cellspacing 定义单元格之间的距离 tr：行 td：单元格 colspan：合并列 rowspan：合并行 th：表头单元格（内容会自动居中并加粗） &lt;caption&gt;：表格标题，在表格上方、剧中 &lt;thead&gt;：表示表格的头部份 &lt;tbody&gt;：表示表格的体部份 &lt;tfoot&gt;：表示表格的脚部份 表单标签form：用于定义表单。可定义一个代表采集用户数据的范围。 action：指定提交数据的URL method：指定提交方式 get： 请求参数会在地址栏中显示，会封装到请求行中 请求参数大小有限制 不太安全 post： 请求参数不会在地址栏中显示，会封装到请求行中 请求参数大小没有限制 较为安全 表单项标签input：可以通过type属性值改变元素展示样式。 type text：文本框 placeholder：指定输入框的提示信息，当输入框内容发生变化，会自动清空提示信息 password：密码框 radio：单选框 要想实现单选，name属性值要一致 给每个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 check：复选框 要想实现选择，name属性值要一致 给每个复选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 file：文件选择框 hidden：隐藏域 按钮： submit：提交按钮，用于提交表单 button：普通按钮 image：图片提交按钮。 lable：标签。其中的for属性一般会和inpu的id属性值对应。select：下拉列表 option：定义可选的列表项 textarea：文本域","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"HTML","slug":"HTML","permalink":"http://rainbowcat.top/tags/HTML/"}]},{"title":"JSP学习笔记","date":"2020-02-10T03:45:18.000Z","path":"2020/02/10/JSP学习笔记/","text":"WEB-INFO目录结构WEB-INF 是Java的WEB应用的安全目录，客户端上访问不到，只有服务端才能访问。web.xml 是项目部署文件。class文件夹 用于存放.class文件。lib文件夹 存放项目所需jar包. JSP页面元素构成静态内容HTML静态文件体 指令 page指令： 位于jsp页面顶端，同一个页面可以有多个page指令。 language：指定jsp页面使用的脚本语言，默认为Java。 import：引用脚本中使用到的类文件。 contentType：指定jsp页面编码方式，默认为text/html，ISO-8859-1。 include指令：将一个外部文件嵌入到当前jsp文件中，并解析页面中的jsp语句。 taglib指令：使用标签库定义新的标签，在jsp页面中启用定制行为。 示例： &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; 注释​ HTML注释：​ &lt;!-- html注释，客户端可见 --&gt;​ JSP注释：​ &lt;%-- jsp注释，客户端不可见 --%&gt;​ JSP脚本中可使用Java注释。 小脚本&lt;%out.println(&quot;这是jsp脚本&quot;)%&gt; 声明在jsp页面中定义变量或者发方法。&lt;! String s = &quot;张三&quot;;&gt; 表达式在jsp页面中执行的表达式。&lt;%=1+1 %&gt; //注意表达式后面不写; JSP内置对象jsp内置对象是web容器创建的一组对象，不使用new关键词就可以使用的内置对象，例如： 123456&lt;% int[] value = &#123;60, 70, 80&#125;; for (int i:value)&#123; out.println(i); // out就是内置对象 &#125; %&gt; jsp九大内置对象常用的五个: out： JspWriter类的实例，向客户端输出内容的常用对象。123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;out内置对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 缓冲区大小：&lt;%=out.getBufferSize()%&gt;byte&lt;br&gt; 缓冲区剩余大小：&lt;%=out.getRemaining()%&gt;byte&lt;br&gt; 是否自动清空缓冲区：&lt;%=out.isAutoFlush()%&gt;&lt;br&gt; &lt;br&gt;&lt;/body&gt;&lt;/html&gt; 预览效果： request： HttpServletRequest类的实例。1234567891011121314151617181920212223242526272829303132333435&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;requesr内置对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;Request内置对象&lt;/h1&gt; &lt;% // 设置请求默认的编码，解决页面中文乱码问题 request.setCharacterEncoding(\"UTF-8\"); // 存储此请求中的属性 request.setAttribute(\"passwd\", \"123456\"); %&gt; 用户名：&lt;%=request.getParameter(\"username\") %&gt; &lt;br&gt; 爱好：&lt;% if (request.getParameterValues(\"favorite\")!=null) &#123; String[] favorites = request.getParameterValues(\"favorite\"); for (int i = 0; i &lt; favorites.length; i++) &#123; out.println(favorites[i] + \"&amp;nbsp&amp;nbsp;\"); &#125; &#125; %&gt;&lt;br&gt; 密码： &lt;%=request.getAttribute(\"passwd\")%&gt;&lt;br&gt; 请求体的MIME类型：&lt;%=request.getContentType()%&gt;&lt;br&gt; 协议类型及版本号：&lt;%=request.getProtocol()%&gt;&lt;br&gt; 服务器主机名：&lt;%=request.getServerName()%&gt;&lt;br&gt; 服务器端口号：&lt;%=request.getServerPort()%&gt;&lt;br&gt; 请求文件的长度：&lt;%=request.getContentLength()%&gt;&lt;br&gt; 请求客户端的IP地址：&lt;%=request.getRemoteAddr()%&gt;&lt;br&gt; 请求的上下文路径：&lt;%=request.getContextPath()%&gt;&lt;br&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 预览效果： 3. response： HttpServletResponse类的实例。 1234567891011121314151617&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;% response.setContentType(\"text/html; charset=utf-8\"); out.print(\"&lt;h1&gt;response内置对象&lt;/h1&gt;\"); out.print(\"&lt;hr&gt;\"); PrintWriter outer = response.getWriter(); //获得输出流对象， // response对象获得的writer对象输出打印时提前于内置out对象 outer.println(\"response对象生成的输出流outer对象\"); out.print(\"&lt;br&gt;\"); out.print(\"&lt;h1&gt;response内置对象&lt;/h1&gt;\"); out.print(\"&lt;hr&gt;\"); out.flush(); PrintWriter outer1 = response.getWriter(); //获得输出流对象， // response对象获得的writer对象输出打印时提前于内置out对象 outer.println(\"response对象生成的输出流outer对象\");// response.sendRedirect(\"request.jsp\"); //请求重定向%&gt; 预览效果： 4. session： 客户端与服务器的一次对话，从第一次打开客户端到其完全关闭的一段时间。 1234567891011121314151617&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;session内置对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;session内置对象&lt;/h1&gt; &lt;hr&gt; &lt;% SimpleDateFormat sdf = new SimpleDateFormat(\"yyy年MM月dd日 HH:mm:ss\"); Date d = new Date(session.getCreationTime()); %&gt; Session创建时间：&lt;%=sdf.format(d)%&gt; &lt;br&gt; Session的ID编号：&lt;%=session.getId()%&gt;&lt;/body&gt;&lt;/html&gt; 预览效果： 5. application： 实现用户间数据的共享，可存放全局变量。开始于服务器的启动，终止于服务器的关闭。在用户的前后链接或不同用户之间的连接中，可以对application对象的同意属性进行操作。 1234567891011121314151617181920212223&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ page import=\"java.util.Enumeration\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;application内置对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;application内置对象&lt;/h1&gt; &lt;% application.setAttribute(\"city\", \"北京\"); application.setAttribute(\"postcode\", \"10000\"); application.setAttribute(\"email\", \"lisi@163.com\"); %&gt; 所在的城市：&lt;%=application.getAttribute(\"city\")%&gt; 中的属性有：&lt;% Enumeration attributes = application.getAttributeNames(); while (attributes.hasMoreElements()) &#123; out.println(attributes.nextElement()+\"&amp;nbsp&amp;nbsp\"); &#125; %&gt;&lt;br&gt; JSP(SERVLET)引擎名及版本号：&lt;%=application.getServerInfo()%&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 预览效果： 不常用的: page： 当前JSP页面本身，有点像类中的this指针。12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;page内置对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;page内置对象&lt;/h1&gt; 当前page页面对象的字符串描述：&lt;%=page.toString()%&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 预览效果：7. pageContext ： 提供了对JSP页面内所有的对象及名字空间的访问。 1234567891011121314151617&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;pageContext&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;pageContext内置对象&lt;/h1&gt; session_page1中的用户名是：&lt;%=pageContext.getSession().getAttribute(\"username\")%&gt; &lt;br&gt; &lt;% //跳转到注册页面 //pageContext.forward(\"reg.jsp\"); //一个页面包含另一个页面 pageContext.include(\"include.jsp\"); %&gt;&lt;/body&gt;&lt;/html&gt; include.jsp includ指令&lt;%@include file=&quot;URL&quot;%&gt; 12345678910&lt;%@ page import=\"java.util.Date\" %&gt;&lt;%@ page import=\"ja&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\"; Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\"); String s = sdf.format(date); out.println(s+\"&lt;br&gt;\");%&gt; 预览效果：8. exception： 是一个异常对象，当一个页面在运行过程中发生了异常，就产生这个对象。如果一个jsp页面要应用此对象，就必须把isErrorPage设定为true，否则无法编译。想要查看该内置对象的实际效果，创建一个exception.jsp文件： 123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isErrorPage=\"true\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;exception&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;exception内置对象&lt;/h1&gt; &lt;hr&gt; 异常消息是：&lt;%=exception.getMessage()%&gt;&lt;br&gt; 异常的字符串描述：&lt;%=exception.toString()%&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 通过exception测试页面来查看（需要新建一个exceptionTest.jsp） 1234567891011121314&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" errorPage=\"exception.jsp\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;exceptionTest&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;测试异常的页面&lt;/h1&gt; &lt;hr&gt; &lt;% //在最上方添加errorPage=\"exceptionTest.jsp\" System.out.println(100/0); //抛出异常 %&gt;&lt;/body&gt;&lt;/html&gt; 预览效果：9. config： 在Servlet初始化时，jsp引擎向它传递信息用的，此信息包括Servlet初始化时需要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）。​ 请求重定向： 客户端行为，response.sendRedirect()，从本质上讲等同于两次请求，前一次的请求对象不会保存，地址栏的URL地址会改变。​ 请求转发： 服务器行为，request.getRequestDispatcher().forward(req,resp)，是一次请求，转发后请求对象保存，地址栏的URL地址不会改变。 include指令和include动作标签includ指令include动作标签&lt;jsp:include page=&quot;URL&quot; flush=&quot;true|false&quot; /&gt; page： 要包含的页面 flush： 被包含的页面是否从缓冲区读取(默认为false) include_action.jsp 文件： 1234567891011&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;includeAction&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;include动作&lt;/h1&gt; &lt;hr&gt; &lt;jsp:include page=\"date.jsp\" flush=\"false\" /&gt;&lt;/body&gt;&lt;/html&gt; date.jsp 文件： 12345678&lt;%@ page contentType=\"text/html;charset=UTF-8\" import=\"java.util.*\" language=\"java\" %&gt;&lt;%@page import=\"java.text.*\" %&gt;&lt;% Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\"); String s = sdf.format(d); out.println(s);%&gt; 预览效果： include指令和include动作比较 includ指令 jsp:include动作 语法格式 &lt;%@ include file=”..” %&gt; &lt;jsp:include page=”..” &gt; 发生作用的时间 页面转换期间 请求期间 包含的内容 文件的实际内容 页面的输出 转换成的Servlet 主页面和包含页面转换为一个Servlet 主页面和包含页面转换为独立的Servlet 编译时间 较慢——资源必须被解析 较快 执行时间 稍快 较慢——每次资源必须被解析 forward动作语法：&lt;jsp:forward page=&quot;URL&quot; /&gt;等同于：request.getRequestDispatcher(&quot;/url&quot;).forward(request,response);首先创建login.jsp文件,将action提交给forward.jsp处理： 12345678910111213141516171819202122232425&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;系统登陆&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;form name=\"loginForm\" action=\"forward.jsp\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;input type=\"submit\" value=\"登陆\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 创建forward.jsp文件，使用forward动作提交给user.jsp进行处理： 1234567891011&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;forward动作&lt;/h3&gt; &lt;hr&gt; &lt;jsp:include page=\"user.jsp\" /&gt;&lt;/body&gt;&lt;/html&gt; user.jsp 文件用于获取用户登陆信息： 12345678910111213141516171819202122&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;用户资料&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;用户资料&lt;/h4&gt;&lt;hr&gt; &lt;% request.setCharacterEncoding(\"utf-8\");%&gt; &lt;% String username = \"\"; String password = \"\"; if (request.getParameter(\"username\")!=null)&#123; username = request.getParameter(\"username\"); &#125; if (request.getParameter(\"password\")!=null)&#123; password = request.getParameter(\"password\"); &#125; %&gt; 用户名：&lt;%=username %&gt;&lt;br&gt; 密码：&lt;%=password %&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 预览效果： param动作&lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot;&gt;常常和&lt;jsp:forward &gt;一起使用，作为其子标签。将login.jsp中的action对象forward.jsp改为dologin.jsp,然后新建一个dologin.jsp文件： 1234567891011&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:forward page=\"user.jsp\"&gt; &lt;jsp:param value=\"admin@163.com\" name=\"email\" /&gt; &lt;/jsp:forward&gt;&lt;/body&gt;&lt;/html&gt; 在user.jsp文件中加入以下代码： 1234567String email &#x3D; &quot;&quot;;if (request.getParameter(&quot;email&quot;)!&#x3D;null)&#123; email &#x3D; request.getParameter(&quot;email&quot;); &#125;电子邮箱：&lt;%&#x3D;email %&gt; 该过程是为了演示param的作用,虽然用户登陆时提交的表单信息中没有email内容，但是用过param可以进行赋值。预览效果： Cookie：是web服务器保存在客户端的一系列文本信息。典型应用一：判定注册用户是否已经登陆网站。典型应用二:“购物车”的处理。生活中Cookie的应用：浏览记录、记住用户名和密码实现自动登录 Cookie的作用： 对特定对象的追踪 保存用户网页浏览记录与习惯 简化登录安全风险：容易泄露用户信息jsp中创建和使用Cookie创建Cookie对象Cookie newCookie = new Cookie(String key, Object value);写入Cookie对象response.addCookie(newCookie);读取Cookie对象Cookie[] cookie = request.getCookies(); 常用方法： 方法名称 说明 void setMaxAge(int expiry) 设置cookie的有效期，单位是秒 void setValue(String vlaue) 在cookie创建后，对cookie进行赋值 String setName() 获取cookie的名称 String grtValue() 获取cookie的值 int getMaxAge() 获取cookie的有效时间，单位是秒 项目案例 登陆界面：login.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;%@ page contentType=\"text/html;charset=UTF-8\" import=\"java.net.*\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;用户登录&lt;/h4&gt; &lt;hr&gt; &lt;% request.setCharacterEncoding(\"utf-8\"); String username = \"\"; String password = \"\"; Cookie[] cookies = request.getCookies(); if (cookies!=null&amp;&amp;cookies.length&gt;0)&#123; for (Cookie c:cookies)&#123; if (c.getName().equals(\"username\"))&#123; username = URLDecoder.decode(c.getValue(), \"utf-8\"); &#125; if (c.getName().equals(\"password\"))&#123; password = URLDecoder.decode(c.getValue(), \"utf-8\"); &#125; &#125; &#125; %&gt; &lt;form name=\"loginForm\" action=\"dologin.jsp\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\" value=\"&lt;%=username %&gt;\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\" value=\"&lt;%=password %&gt;\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;input type=\"checkbox\" name=\"isCookie\" checked=\"checked\" /&gt;十天内记住我的登陆状态&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" align=\"center\"&gt;&lt;input type=\"submit\" value=\"登陆\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 登陆处理：dologin.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%@ page contentType=\"text/html;charset=UTF-8\" import=\"java.net.*\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;登陆成功&lt;/h4&gt; &lt;hr&gt; &lt;br&gt; &lt;% request.setCharacterEncoding(\"utf-8\"); //先判断是否选择了记住登陆状态 String[] isCookie = request.getParameterValues(\"isCookie\"); if (isCookie!=null&amp;&amp;isCookie.length&gt;0)&#123; // 把用户名和密码保存在Cookie对象中 // 使用URLEncoder.encode()方法将Cookie中用户名或者密码的中文进行编码 String username = URLEncoder.encode(request.getParameter(\"username\"), \"utf-8\"); String password = URLEncoder.encode(request.getParameter(\"password\"), \"utf-8\"); Cookie usernameCookie = new Cookie(\"username\", username); Cookie passwordCookie = new Cookie(\"password\", password); // 设置Cookie最大生存时间 usernameCookie.setMaxAge(486000); passwordCookie.setMaxAge(486000); // 将数据保存到Cookie对象中 response.addCookie(usernameCookie); response.addCookie(passwordCookie); &#125; else &#123; // 不勾选记住登陆状态时的操作 Cookie[] cookies = request.getCookies(); if (cookies!=null&amp;&amp;cookies.length&gt;0)&#123; for (Cookie c:cookies)&#123; if (c.getName().equals(\"username\")||c.getName().equals(\"password\"))&#123; c.setMaxAge(0);// 设置cookie失效 response.addCookie(c);//重新保存 &#125; &#125; &#125; &#125; %&gt; &lt;a href=\"users.jsp\" target=\"_blank\"&gt;查看用户信息&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 用户界面：users.jsp 123456789101112131415161718192021222324252627282930&lt;%@ page contentType=\"text/html;charset=UTF-8\" import=\"java.net.*\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;用户信息&lt;/h4&gt; &lt;hr&gt; &lt;% request.setCharacterEncoding(\"utf-8\"); String username = \"\"; String password = \"\"; Cookie[] cookies = request.getCookies(); if (cookies!=null&amp;&amp;cookies.length&gt;0)&#123; for (Cookie c:cookies)&#123; if (c.getName().equals(\"username\"))&#123; // 解码 username = URLDecoder.decode(c.getValue(), \"utf-8\"); &#125; if (c.getName().equals(\"password\"))&#123; password = URLDecoder.decode(c.getValue(), \"utf-8\"); &#125; &#125; &#125; %&gt; &lt;br&gt; 用户名：&lt;%=username %&gt;&lt;br&gt; 密码：&lt;%=password %&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 首先我们来看一下登陆界面（由于测试的目标仅是Cookie的作用，并未涉及到登陆验证）由于这是第一次启动该项目，表单中并没有数据。我们填入相应信息，取消勾选记住登陆状态，然后尝试登陆-点击“查看用户信息”。弹出的页面并未显示用户数据：关闭浏览器客户端，再次打开登陆界面：重新填写登录信息，此次勾选记住登陆状态，重复上述步骤：重新打开的登陆界面包含了上次登录的用户信息： Session和Cookie对比 Session Cookie 在服务器端保存用户信息 在客户端保存用户信息 Session中保存的是Object类型 Cookie保存的是String类型 随会话的结束而将其存储的数据销毁 可以长期保存在客户端 保存重要信息 保存不重要的用户信息 JavaBeanJavabeans就是符合某种特定的规范的Java类。使用Javabeans的好处是解决代码重复编写，减少代码冗余，功能区分明确，提高了代码的维护性。 设计原则 公有类 无参的公有构造方法 属性私有 getter和setter方法12345678910111213//公有类public class Students&#123; //属性私有 private String name; private int age; //无参的公有构造方法 public Students()&#123;&#125; //getter和setter方法 public void setName(String name)&#123;this.name=name;&#125; public String getName()&#123;return this.name;&#125; public void setAge(int age)&#123;this.age=age;&#125; public int getAge()&#123;return this.age;&#125;&#125; 什么是JSP动作JSP动作元素（action elements），动作元素为请求处理阶段提供信息。动作元素遵循XML元素的语法，有一个包含元素名的开始标签，可以有属性、可选内容、与开始标签匹配的结束标签。 第一类是与存取JavaBean有关的，包括： &lt;jsp:useBean&gt; &lt;jsp:setProperty&gt;&lt;jsp:getProperty&gt; 第二类是JSP1.2就看似是有的基本元素，包括6个动作元素：&lt;jsp:include&gt;&lt;jsp:forward&gt;&lt;jsp:param&gt;&lt;jsp:plugin&gt;&lt;jsp:params&gt;&lt;jsp:fallback&gt; 第三类是JSP2.0新增加的元素，主要与JSP Document有关，包括6个元素：&lt;jsp:root&gt;&lt;jsp:declaration&gt;&lt;jsp:scriptlet&gt;&lt;jsp:expression&gt;&lt;jsp:text&gt;&lt;jsp:output&gt; 第四类是JSP2.0新增的动作元素，主要用来动态生成XML元素标签的值，包括3个动作：&lt;jsp:attribute&gt;&lt;jsp:body&gt;&lt;jsp:element&gt; 第五类是JSP2.0新增的动作元素，主要是用在Tag File中，有2个元素：&lt;jsp:invoke&gt;&lt;jsp:dobody1.用普通方式创建JavaBean实例： 首先在src下建立实体类 在jsp文件中使用page指令import实体类用户实体类：12345678910111213141516171819202122package com.po;public class User &#123; private String username; private String password; public User() &#123; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125;&#125; 使用内置对象调用JavaBean实例中的属性123456789101112131415161718&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ page import=\"com.po.User\"%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;使用普通方式创建JavaBean的实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% User user = new User(); user.setUsername(\"admin\"); user.setPassword(\"123456\"); %&gt; &lt;h1&gt;使用普通方式创建JavaBean的实例&lt;/h1&gt; &lt;hr&gt; 用户名：&lt;%=user.getUsername()%&gt;&lt;br&gt; 密码：&lt;%=user.getPassword()%&gt;&lt;br&gt; &lt;/body&gt;&lt;/html&gt; 预览效果： 2.在jsp页面中通常使用jsp动作标签使用JavaBean，常用的有以下三个： useBeans&lt;jsp:userBean id=&quot;标识符&quot; class=&quot;java&quot; scope=&quot;作用范围&quot; /&gt; &lt;jsp:：表示这是jsp动作元素 useBean：表示这是一个useBean标签 id：所实例化的JavaBeans唯一标识符 class：所用到的是哪个Java类，包括包名和类名 scope：该标签的作用范围使用useBeans动作创建JavaBean的实例,但是由于实体类中并未给属性赋值，故此处输出的属性值为null。12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;使用useBeans动作创建JavaBean的实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;jsp:useBean id=\"myUsers\" class=\"com.po.User\" scope=\"page\"/&gt; &lt;h1&gt;使用useBeans动作创建JavaBean的实例&lt;/h1&gt; &lt;hr&gt; 用户名：&lt;%=myUsers.getUsername()%&gt;&lt;br&gt; 密码：&lt;%=myUsers.getPassword()%&gt;&lt;br&gt; &lt;/body&gt;&lt;/html&gt; 预览效果： 2. setProperty 作用：给已经实例化的JavaBean对象的属性赋值，一共有四种形式： 1. &lt;jsp:serProperty name=&quot;JavaBean实例名&quot; property=&quot;*&quot; /&gt;（跟表单关联） 2. &lt;jsp:serProperty name=&quot;JavaBean实例名&quot; property=&quot;JavaBean属性名&quot; /&gt;（跟表单关联） 3. &lt;jsp:serProperty name=&quot;JavaBean实例名&quot; property=&quot;JavaBean属性名&quot; value=&quot;BeanValue&quot;/&gt;（手工设置） 4. &lt;jsp:serProperty name=&quot;JavaBean实例名&quot; property=&quot;propertyName&quot; param=&quot;request对象中的参数名&quot; /&gt;（跟request参数关联）在演示setProperty的使用效果时，我们首先建立一个带有表单的登陆系统：login.jspproperty=”*”，表示此时的属性从表单中进行匹配。 12345678910111213141516171819202122232425&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;登陆系统&lt;/h1&gt; &lt;hr&gt; &lt;form name=\"login\" action=\"dologin.jsp?mypass=999999\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\" value=\"\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\" value=\"\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" align=\"center\"&gt;&lt;input type=\"submit\" value=\"登陆\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 预览效果：用户通过登陆界面输入登陆所需信息，而登陆的逻辑操作由dologin.jsp完成： 12345678910111213141516&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:useBean id=\"myUsers\" class=\"com.po.User\" scope=\"page\"/&gt; &lt;h1&gt;setProperty动作元素使用方法&lt;/h1&gt; &lt;hr&gt; &lt;!-- 根据表单自动匹配所有的属性 --&gt; &lt;jsp:setProperty name=\"myUsers\" property=\"*\" /&gt; &lt;!-- 使用传统表达式方式获取用户名和密码 --&gt; 用户名：&lt;%=myUsers.getUsername()%&gt;&lt;br&gt; 密码：&lt;%=myUsers.getPassword()%&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 然后在登陆界面提交登录信息（用户名：root 密码：123456），就能获得如下页面：property=”JavaBean属性名”，表示此时的属性由JavaBean进行指定，只获取指定的属性值。 12&lt;!-- 根据表单匹配部分属性 --&gt; &lt;jsp:setProperty name=\"myUsers\" property=\"username\" /&gt; 由于代码中未曾指定password这一属性，输出的结果只有用户名：property=”JavaBean属性名” value=”BeanValue”,该方法在赋值时由value的值决定，并不会使用表单中的值。 123&lt;!-- 跟表单无关，通过手工赋值给属性 --&gt; &lt;jsp:setProperty name=\"myUsers\" property=\"username\" value=\"李四\"/&gt; &lt;jsp:setProperty name=\"myUsers\" property=\"password\" value=\"888888\"/&gt; 此处对”username”和”password”分别赋值为”李四”和”888888”,输出的结果就不会再是”root”和”123456”了。property=”propertyName” param=”request对象中的参数名”,此方法可以使用URL传参进行赋值。 123&lt;!-- 通过URL传参数给属性赋值 --&gt;&lt;jsp:setProperty name=\"myUsers\" property=\"username\" /&gt;&lt;jsp:setProperty name=\"myUsers\" property=\"password\" param=\"mypass\" /&gt; login.jsp 文件中action=&quot;dologin.jsp?mypass=999999&quot;,通过URL把密码”999999”进行传递：3. getProperty 作用：获取指定JavaBean对象的属性值 &lt;jsp:getProperty name=&quot;JavaBean实例名&quot; property=属性名 /&gt; 123&lt;!-- 使用getProperty方法获取用户名和密码 --&gt; 用户名：&lt;jsp:getProperty name=\"myUsers\" property=\"username\" /&gt;&lt;br&gt; 密码：&lt;jsp:getProperty name=\"myUsers\" property=\"password\" /&gt;&lt;br&gt; 3.JavaBean的四个作用范围:使用JavaBeans的scope属性可以用来指定JavaBean的作用范围。 page：仅在当前页面有效。 request：可通过HttpRequest.getAttribute()方法取得JavaBean对象。 session：可通过HttpSession.getAttribute()方法取得JavaBean对象。 application：可通过application.getAttribute()方法取得JavaBean对象。为了方便进行演示，在login.jsp文件中添加一个超链接:1&lt;a href=\"testScope.jsp\"&gt;测试scope四个作用于范围&lt;/a&gt; 并且新建一个testScope.jsp文件，将dologin.jsp文件中的”scope”属性改为”application” 来查看效果:1234567891011121314151617181920&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ page import=\"com.po.User\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;TestScope&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;JavaBean的四个作用于范围&lt;/h1&gt; &lt;hr&gt; &lt;jsp:useBean id=\"myUsers\" class=\"com.po.User\" scope=\"application\" /&gt; 用户名：&lt;jsp:getProperty name=\"myUsers\" property=\"username\" /&gt;&lt;br&gt; 密码：&lt;jsp:getProperty name=\"myUsers\" property=\"password\" /&gt;&lt;br&gt; &lt;!-- 使用内置对象获取 --&gt; &lt;hr&gt; &lt;!-- application --&gt; 用户名：&lt;%=((User)application.getAttribute(\"myUsers\")).getUsername()%&gt;&lt;br&gt; 密码：&lt;%=((User)application.getAttribute(\"myUsers\")).getPassword()%&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 预览效果：将dologin.jsp和testScope.jsp文件中的”scope”属性改为”session” 来查看效果: 123&lt;!-- session --&gt; 用户名：&lt;%=((User)session.getAttribute(\"myUsers\")).getUsername()%&gt;&lt;br&gt; 密码：&lt;%=((User)session.getAttribute(\"myUsers\")).getPassword()%&gt;&lt;br&gt; 预览效果：将dologin.jsp和testScope.jsp文件中的”scope”属性改为”request” 来查看效果: 123&lt;!-- request --&gt; 用户名：&lt;%=((User)request.getAttribute(\"myUsers\")).getUsername()%&gt;&lt;br&gt; 密码：&lt;%=((User)request.getAttribute(\"myUsers\")).getPassword()%&gt;&lt;br&gt; 预览效果：将dologin.jsp和testScope.jsp文件中的”scope”属性改为”page” 来查看效果: 1234567891011&lt;!-- page --&gt; &lt;% String username = \"\"; String password = \"\"; if (pageContext.getAttribute(\"myUsers\")!=null)&#123; username = ((User)pageContext.getAttribute(\"myUsers\")).getUsername(); password = ((User)pageContext.getAttribute(\"myUsers\")).getPassword(); &#125; %&gt; 用户名：&lt;%=username%&gt;&lt;br&gt; 密码：&lt;%=password%&gt;&lt;br&gt; 预览效果：","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JSP","slug":"JSP","permalink":"http://rainbowcat.top/tags/JSP/"}]},{"title":"Markdown基本语法","date":"2020-02-04T05:32:40.000Z","path":"2020/02/04/Markdown基本语法/","text":"基本语法标题在文字前添加#，使之成为标题。一个#是一级标题，两个#是二级标题，以此类推到六级标题。注：标准语法一般在#后面跟个空格在写文字。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 对应的HTML： 123456&lt;h1&gt;这是一级标题&lt;&#x2F;h1&gt;&lt;h2&gt;这是二级标题&lt;&#x2F;h2&gt;&lt;h3&gt;这是三级标题&lt;&#x2F;h3&gt;&lt;h4&gt;这是四级标题&lt;&#x2F;h4&gt;&lt;h5&gt;这是五级标题&lt;&#x2F;h5&gt;&lt;h6&gt;这是六级标题&lt;&#x2F;h6&gt; 段落中间没有空行的连续不断的几行文字被视为一个段落。Markdown： 12Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 对应的HTML: 12345&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;br&gt;Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;&#x2F;p&gt; 行内格式12文本**加黑**文本*斜体* 预览：文本加黑文本斜体对应的HTML:p 1234567&lt;p&gt; 文本 &lt;strong&gt;加黑&lt;&#x2F;strong&gt; &lt;br&gt; 文本 &lt;em&gt;斜体&lt;&#x2F;em&gt;&lt;&#x2F;p&gt; 引用块Markdown: 123456&gt; 引用段落一。&gt;&gt; 引用段落二。&gt;&gt; 内嵌引用块段落一。&gt;&gt; ### 引用块内的标题 预览 引用段落一。 引用段落二。 内嵌引用块段落一。 引用块内的标题 对应的HTML: 12345678&lt;blockquote&gt; &lt;p&gt;引用段落一。&lt;&#x2F;p&gt; &lt;p&gt;引用段落二。&lt;&#x2F;p&gt; &lt;blockquote&gt; &lt;p&gt;内嵌引用块段落一。&lt;&#x2F;p&gt; &lt;&#x2F;blockquote&gt; &lt;h3 id&#x3D;&quot;引用块内的标题&quot;&gt;引用块内的标题&quot;&lt;&#x2F;h3&gt;&lt;&#x2F;blockquote&gt; 超链接Markdown: 1234567行内式[博客](https:&#x2F;&#x2F;1029322685.github.io&#x2F; &quot;Leon&#39;s blog&quot;)链接，带title。行内式[GitHub](https:&#x2F;&#x2F;github.com&#x2F;1029322685)链接。引用式[博客][1]链接。引用式[GitHub][2]链接，带title。[1]:https:&#x2F;&#x2F;1029322685.github.io&#x2F;[2]:https:&#x2F;&#x2F;github.com&#x2F;1029322685 &quot;我的GitHub主页&quot; 预览：行内式博客链接，带title。行内式GitHub链接。引用式博客链接。引用式GitHub链接，带title。 对应的HTML: 1234&lt;p&gt;行内式&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;1029322685.github.io&#x2F;&quot; title&#x3D;&quot;Leon&#39;s blog&quot;&gt;博客&lt;&#x2F;a&gt;链接，带title。&lt;&#x2F;p&gt;&lt;p&gt;行内式&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;1029322685&quot;&gt;GitHub&lt;&#x2F;a&gt;链接。&lt;&#x2F;p&gt;&lt;p&gt;引用式&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;1## 图片029322685.github.io&#x2F;&quot;&gt;博客&lt;&#x2F;a&gt;链接。&lt;&#x2F;p&gt;&lt;p&gt;引用式&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;1029322685&quot; title&#x3D;&quot;Leon&#39;s blog&quot;&gt;GitHub&lt;&#x2F;a&gt;链接，带title。&lt;&#x2F;p&gt; 图片在超链接的写法前加一个！就是引用图片的方法。Markdown: 1![图片加载失败](&#x2F;images&#x2F;pic01.jpg &quot;pic&quot;) 预览：对应的HTML: 1&lt;img src&#x3D;&quot;images&#x2F;pic01.jpg&quot; alt&#x3D;&quot;图片加载失败&quot; title&#x3D;&quot;pic&quot;&gt; 列表Markdown: 1234567- list one- list two- list three1. list one2. list two3. list three 预览： list one list two list three list one list two list three 对应的HTML: 12345678910&lt;ul&gt; &lt;li&gt;list one&lt;&#x2F;li&gt; &lt;li&gt;list two&lt;&#x2F;li&gt; &lt;li&gt;list three&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;ol&gt; &lt;li&gt;list one&lt;&#x2F;li&gt; &lt;li&gt;list two&lt;&#x2F;li&gt; &lt;li&gt;list three&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; 其中无序列表的标记可以使用 +、- 或 *有序列表前的数字可以是乱序的 水平分割线使用一个单独行里的三个或以上 *、- 来生产一条水平分割线，它们之间可以有空格。Markdown: 1----- 预览：对应的HTML: 1&lt;hr&#x2F;&gt; 转义符反斜线\\用于插入在 Markdown 语法中有特殊作用的字符。特殊字符包括： 123456789101112\\&#96;*_&#123;&#125;[]()#+-.! Markdown: 12这是*演示*文本这是\\*演示\\*文本 预览：这是演示文本这是*演示*文本 嵌入HTMLMarkdown 标记语言的目的不是替代 HTML，也不是发明一种更便捷的插入 HTML 标签的方式。它对应的只是 HTML 标签的一个很小的子集。 对于那些没有办法用 Markdown 语法来对应的 HTML 标签，直接使用 HTML 来写就好了。 扩展语法删除线Markdown: 1这就是~~删除线~~ 预览：这就是删除线 语法高亮在上面的代码块语法基础上，在第一组 ``` 之后添加代码的语言，如 ‘javascript’ 或 ‘js’，即可将代码标记为 JavaScript： 预览： 123window.addEventListener('load', function() &#123; console.log('window loaded');&#125;); 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。Markdown: 1234name | age---- | ---LearnShare | 12Mike | 32 预览： name age LearnShare 12 Mike 32 为了使Markdown更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。 Task ListMarkdown: 123456- [ ] Eat- [x] Code - [x] HTML - [x] CSS - [x] JavaScript- [ ] Sleep 预览： Eat Code HTML CSS JavaScript Sleep","tags":[{"name":"学习","slug":"学习","permalink":"http://rainbowcat.top/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"分享","slug":"分享","permalink":"http://rainbowcat.top/tags/%E5%88%86%E4%BA%AB/"},{"name":"Markdown","slug":"Markdown","permalink":"http://rainbowcat.top/tags/Markdown/"}]}]